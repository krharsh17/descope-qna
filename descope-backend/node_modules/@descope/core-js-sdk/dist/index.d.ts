type JSONSerializable = string | number | boolean | null | Array<JSONSerializable>;
type FlowInput = Record<string, JSONSerializable>;

type DeviceInfo = {
    webAuthnSupport?: boolean;
};
type LastAuth = {
    authMethod?: AuthMethod;
    oauthProvider?: string;
    name?: string;
    loginId?: string;
};
type RedirectAuth = {
    callbackUrl: string;
    codeChallenge: string;
};
type AuthMethod = 'magiclink' | 'enchantedlink' | 'otp' | 'totp' | 'oauth' | 'saml' | 'webauthn';
type SdkFn$1 = (...args: any[]) => Promise<SdkResponse<ResponseData>>;
type MaskedPhone = {
    maskedPhone: string;
};
type MaskedEmail = {
    maskedEmail: string;
};
/** User base details from Descope API */
type User = {
    email?: string;
    name?: string;
    givenName?: string;
    middleName?: string;
    familyName?: string;
    phone?: string;
};
/** User extended details from Descope API */
type UserResponse = User & {
    loginIds: string[];
    userId: string;
    verifiedEmail?: boolean;
    verifiedPhone?: boolean;
    picture?: string;
    roleNames?: string[];
    userTenants?: UserTenant[];
    createTime: number;
    TOTP: boolean;
    SAML: boolean;
    OAuth?: Record<string, boolean>;
    customAttributes?: Record<string, any>;
    status: string;
};
/** A tenant association mapping  */
type UserTenant = {
    tenantId: string;
    roleNames?: string[];
    tenantName: string;
};
/** Login options to be added to the different authentication methods */
type LoginOptions = {
    stepup?: boolean;
    mfa?: boolean;
    customClaims?: Record<string, any>;
};
/** Authentication info result from the various JWT validations  */
type JWTResponse = {
    sessionJwt: string;
    refreshJwt?: string;
    cookieDomain?: string;
    cookiePath?: string;
    cookieMaxAge?: number;
    cookieExpiration?: number;
    user?: UserResponse;
    firstSeen?: boolean;
};
/** Authentication info result from exchanging access keys for a session */
type ExchangeAccessKeyResponse = {
    keyId: string;
    sessionJwt: string;
    expiration: number;
};
/** The response returned from the various start webauthn functions */
type WebAuthnStartResponse = {
    transactionId: string;
    options: string;
    create: boolean;
};
/** Enchanted link response */
type EnchantedLinkResponse = {
    /** Pending reference URL to poll while waiting for user to click magic link */
    pendingRef: string;
    /** Link id, on which link the user should click */
    linkId: string;
    /** Email to which the link was sent to */
    maskedEmail: string;
};
/** URL response to redirect user in case of OAuth or SSO */
type URLResponse = {
    url: string;
};
/** TOTP response with the TOTP details */
type TOTPResponse = {
    provisioningURL: string;
    image: string;
    key: string;
};
/** Password reset response with details according to response method */
type PasswordResetResponse = {
    resetMethod: string;
    pendingRef?: string;
    linkId?: string;
    maskedEmail: string;
};
/** A subset of the password policy that can be checked on the client side for better UX */
type PasswordPolicyResponse = {
    minLength: number;
    lowercase: boolean;
    uppercase: boolean;
    number: boolean;
    nonAlphanumeric: boolean;
};
/** Phone delivery methods which are currently supported */
declare enum DeliveryPhone {
    sms = "sms",
    whatsapp = "whatsapp"
}
declare enum DeliveryEmail {
    email = "email"
}
/** All delivery methods currently supported */
type DeliveryMethods = DeliveryPhone | DeliveryEmail;
declare const DeliveryMethods: {
    readonly email: DeliveryEmail.email;
    readonly sms: DeliveryPhone.sms;
    readonly whatsapp: DeliveryPhone.whatsapp;
};
/** All flow execution statuses
 *  - waiting - flow execution is waiting for user interaction
 *  - running - flow execution is currently running
 *  - completed - flow execution completed successfully
 *  - failed - flow execution failed
 */
declare enum FlowStatus {
    waiting = "waiting",
    running = "running",
    completed = "completed",
    failed = "failed"
}
/** All flow response action
 *  - screen - next action is to render  screen
 *  - poll - next action is poll for next after timeout
 *  - redirect - next action is to redirect (redirection details in 'redirect' attribute)
 *  - webauthnCreate/webauthnGet - next action is to prompt webauthn (details in 'webauthn' attribute)
 *  - none - no next action
 */
type FlowAction = 'screen' | 'poll' | 'redirect' | 'webauthnCreate' | 'webauthnGet' | 'none';
/** Flow response with flow execution details */
type FlowResponse = {
    executionId: string;
    stepId: string;
    stepName: string;
    status: FlowStatus;
    action: FlowAction;
    screen?: {
        id: string;
        state: Record<string, any>;
    };
    redirect?: {
        url: string;
    };
    samlIdpResponse?: {
        url: string;
        samlResponse: string;
        relayState: string;
    };
    webauthn?: {
        transactionId: string;
        options: string;
        create: boolean;
    };
    error?: {
        code: string;
        description: string;
        message: string;
    };
    authInfo?: JWTResponse;
    lastAuth?: Pick<LastAuth, 'authMethod' | 'oauthProvider'>;
};
type Options = {
    redirectUrl?: string;
    location?: string;
    tenant?: string;
    deviceInfo?: DeviceInfo;
    lastAuth?: LastAuth;
    redirectAuth?: RedirectAuth;
    oidcIdpStateId?: string;
    preview?: boolean;
    samlIdpStateId?: string;
    samlIdpUsername?: string;
    ssoAppId?: string;
    abTestingKey?: number;
    startOptionsVersion?: number;
    client?: Record<string, any>;
};
type ResponseData = Record<string, any>;
/**
 * Response from our SDK calls which includes the result (ok, code, error).
 * The relevant data is provided in the more specific interfaces extending SdkResponse.
 */
type SdkResponse<T extends ResponseData> = {
    code?: number;
    ok: boolean;
    response?: Response;
    error?: {
        errorCode: string;
        errorDescription: string;
        errorMessage?: string;
        retryAfter?: string;
    };
    data?: T;
};
/** Different delivery method */
type Deliveries<T extends Record<DeliveryMethods, SdkFn$1>> = {
    [S in DeliveryMethods]: T[S];
};
type DeliveriesPhone<T extends Record<DeliveryPhone, SdkFn$1> | SdkFn$1> = {
    [S in DeliveryPhone]: T extends Record<DeliveryPhone, SdkFn$1> ? T[S] : T;
};
/** Logger type that supports the given levels (debug, log, error) */
type Logger = Pick<Console, 'debug' | 'log' | 'error' | 'warn'>;
type UpdateOptions<T extends boolean> = {
    addToLoginIDs?: T;
    onMergeUseExisting?: T extends true ? boolean : never;
};

declare enum OAuthProviders {
    facebook = "facebook",
    github = "github",
    google = "google",
    microsoft = "microsoft",
    gitlab = "gitlab",
    apple = "apple",
    discord = "discord",
    linkedin = "linkedin",
    slack = "slack"
}
type StartFn = (redirectURL?: string, loginOptions?: LoginOptions, token?: string) => Promise<SdkResponse<URLResponse>>;
type Providers<T> = Record<keyof typeof OAuthProviders, T>;

type EnchantedLinkSignInFn = (loginId: string, uri: string) => Promise<SdkResponse<EnchantedLinkResponse>>;
type EnchantedLinkSignUpFn = (loginId: string, uri: string, user?: User) => Promise<SdkResponse<EnchantedLinkResponse>>;
/** Polling configuration for session waiting */
type WaitForSessionConfig = {
    pollingIntervalMs: number;
    timeoutMs: number;
};

/** Request configuration including headers, query params and token */
type HttpClientReqConfig = {
    headers?: HeadersInit;
    queryParams?: {
        [key: string]: string;
    };
    token?: string;
};
/** HTTP methods we use in the client */
declare enum HTTPMethods {
    get = "GET",
    delete = "DELETE",
    post = "POST",
    put = "PUT"
}
/** HTTP Client type that implements the HTTP method calls. Descopers can provide their own HTTP client although required only in rare cases. */
type HttpClient = {
    get: (path: string, config?: HttpClientReqConfig) => Promise<Response>;
    post: (path: string, body?: any, config?: HttpClientReqConfig) => Promise<Response>;
    put: (path: string, body?: any, config?: HttpClientReqConfig) => Promise<Response>;
    delete: (path: string, config?: HttpClientReqConfig) => Promise<Response>;
    hooks?: Hooks;
};
/** For before-request hook allows overriding parts of the request */
type RequestConfig = {
    path: string;
    headers?: HeadersInit;
    queryParams?: {
        [key: string]: string;
    };
    body?: any;
    method: HTTPMethods;
    token?: string;
};
type BeforeRequest = (config: RequestConfig) => RequestConfig;
type AfterRequest = (req: RequestConfig, res: Response) => void | Promise<void>;
/** Hooks before and after the request is made */
type Hooks = {
    beforeRequest?: BeforeRequest;
    afterRequest?: AfterRequest;
};

/** Transform the Promise Response to our internal SdkResponse implementation
 * @param response The Response promise from fetch
 * @param transform Optionally transform the response JSON to another type
 */
declare function transformResponse<T extends ResponseData, S extends ResponseData = T>(response: Promise<Response>, transform?: (data: T) => S): Promise<SdkResponse<S>>;

type IsObject<T> = T extends Array<any> ? false : T extends Function ? false : T extends object ? true : false;
type Tail<T extends ReadonlyArray<string>> = T extends readonly [
    head: any,
    ...tail: infer Tail_
] ? Tail_ : never;
type Head<T extends ReadonlyArray<string>> = T extends readonly [] ? never : T[0];
type SdkResponseType<F extends SdkFn<ResponseData>> = F extends SdkFn<infer U> ? U : never;
type SdkFnWrapperInternal<F extends SdkFn<ResponseData>, R extends ResponseData> = (fn: (...args: Parameters<F>) => ReturnType<F>) => (...args: Parameters<F>) => Promise<SdkResponse<R extends Record<string, never> ? SdkResponseType<F> : SdkResponseType<F> & R>>;
type PrependDot<T extends string> = [T] extends [never] ? '' : `.${T}`;
type SdkFnsPaths<T extends object> = keyof T extends infer K ? K extends string & keyof T ? IsObject<T> extends false ? never : T[K] extends SdkFn<ResponseData> ? K : IsObject<T[K]> extends false ? never : T[K] extends object ? `${K}${PrependDot<SdkFnsPaths<T[K]>>}` : never : never : never;
type ReplacePaths<Obj extends object, Paths extends ReadonlyArray<string>, WrapperData extends Record<string, any>> = Head<Paths> extends never ? Obj : Tail<Paths> extends ReadonlyArray<string> ? ReplacePaths<ReplacePath<Obj, Head<Paths>, WrapperData>, Tail<Paths>, WrapperData> : ReplacePath<Obj, Head<Paths>, WrapperData>;
type ReplacePath<Obj, Path extends string, WrapperData extends Record<string, any>> = Path extends `${infer Head}.${infer Tail}` ? {
    [Key in keyof Obj]: Key extends Head ? ReplacePath<Obj[Key], Tail, WrapperData> : Obj[Key];
} : {
    [Key in keyof Obj]: Key extends Path ? Obj[Key] extends SdkFn<ResponseData> ? ReturnType<SdkFnWrapperInternal<Obj[Key], WrapperData>> : Obj[Key] : Obj[Key];
};
type SdkFn<T extends ResponseData> = (...args: any) => Promise<SdkResponse<T>>;
type SdkFnWrapper<Z extends ResponseData> = <A extends any[], R extends ResponseData>(fn: (...args: A) => Promise<SdkResponse<R>>) => (...args: A) => Promise<SdkResponse<Z extends Record<string, never> ? R : Z & R>>;

/**
 * A wrapper function that allows to wrap multiple Sdk function
 * @param obj: The Sdk instance you want to wrap
 * @param paths: A readonly list of paths of the functions you want to wrap
 * @param wrapper: Your wrapper function, it should gets an Sdk function and return a new Sdk function
 * @returns a mutated instance of the Sdk with updated type definitions based on your wrapper return type
 *
 * Usage example:
 *
 * // Assuming this is our SDK instance
 * const sdk = {
 *    me: (token) => {...}
 *    flow: {
 *       start: (...params) => {...}
 *       next: (...params) => {...}
 *    }
 *    ...
 * }
 *
 * // This is our wrapper
 * const wrapper = (sdkFn) => async (...args) => {
 *    const sdkResponse = await sdkFn(...args)
 *
 *    // Modify return value
 *    return {...sdkResponse, data: {...sdkResponse.data, myCustomAttribute: 'hello'}}
 * }
 *
 * // And those are the paths we want to wrap
 * const paths = ['flow.start', 'flow.next'] as const // You MUST add as const!
 *
 * // We can wrap our SDK functions with the wrapper we created in this way
 * const newlyTypedSdk = wrapWith(sdk, paths, wrapper)
 *
 * Now the 2 wrapped functions will have the updated type based on the wrapper return value
 */
declare const wrapWith: <Obj extends object, Paths extends readonly SdkFnsPaths<Obj>[], WrapperData extends ResponseData>(obj: Obj, paths: Paths, wrapper: SdkFnWrapper<WrapperData>) => ReplacePaths<Obj, Paths, WrapperData>;

declare const _default$1: {
    TOO_MANY_REQUESTS: number;
};

/** Descope SDK client with delivery methods enum.
 *
 * Please see full documentation at {@link https://docs.descope.com/guides Descope Docs}
 * @example Usage
 *
 * ```js
 * import descopeSdk from '@descope/core-js-sdk';
 *
 * const myProjectId = 'xxx';
 * const sdk = descopeSdk({ projectId: myProjectId });
 *
 * const userLoginId = 'loginId';
 * sdk.otp.signIn.email(userLoginId);
 * const jwtResponse = sdk.otp.verify.email(userIdentifier, codeFromEmail);
 * ```
 */
declare const _default: ((config: Omit<{
    projectId: string;
    logger?: Logger;
    baseUrl?: string;
    hooks?: Hooks;
    cookiePolicy?: RequestCredentials;
    baseHeaders?: HeadersInit;
    fetch?: typeof fetch;
}, "hooks"> & {
    hooks?: {
        beforeRequest?: BeforeRequest | BeforeRequest[];
        afterRequest?: AfterRequest | AfterRequest[];
    };
}) => {
    accessKey: {
        exchange: (accessKey: string) => Promise<SdkResponse<ExchangeAccessKeyResponse>>;
    };
    otp: {
        verify: {
            sms: (loginId: string, code: string) => Promise<SdkResponse<JWTResponse>>;
            whatsapp: (loginId: string, code: string) => Promise<SdkResponse<JWTResponse>>;
            email: (loginId: string, code: string) => Promise<SdkResponse<JWTResponse>>;
        };
        signIn: Deliveries<{
            sms: (loginId: string) => Promise<SdkResponse<MaskedPhone>>;
            whatsapp: (loginId: string) => Promise<SdkResponse<MaskedPhone>>;
            email: (loginId: string) => Promise<SdkResponse<MaskedEmail>>;
        }>;
        signUp: Deliveries<{
            sms: (loginId: string, user?: User) => Promise<SdkResponse<MaskedPhone>>;
            whatsapp: (loginId: string, user?: User) => Promise<SdkResponse<MaskedPhone>>;
            email: (loginId: string, user?: User) => Promise<SdkResponse<MaskedEmail>>;
        }>;
        signUpOrIn: Deliveries<{
            sms: (loginId: string) => Promise<SdkResponse<MaskedPhone>>;
            whatsapp: (loginId: string) => Promise<SdkResponse<MaskedPhone>>;
            email: (loginId: string) => Promise<SdkResponse<MaskedEmail>>;
        }>;
        update: {
            email: <T extends boolean>(loginId: string, email: string, token?: string, updateOptions?: UpdateOptions<T>) => Promise<SdkResponse<MaskedEmail>>;
            phone: DeliveriesPhone<(<T_1 extends boolean>(loginId: string, phone: string, token?: string, updateOptions?: UpdateOptions<T_1>) => Promise<SdkResponse<MaskedPhone>>)>;
        };
    };
    magicLink: {
        verify: (token: string) => Promise<SdkResponse<JWTResponse>>;
        signIn: Deliveries<{
            sms: (loginId: string, uri: string) => Promise<SdkResponse<MaskedPhone>>;
            whatsapp: (loginId: string, uri: string) => Promise<SdkResponse<MaskedPhone>>;
            email: (loginId: string, uri: string) => Promise<SdkResponse<MaskedEmail>>;
        }>;
        signUp: Deliveries<{
            sms: (loginId: string, uri: string, user?: User) => Promise<SdkResponse<MaskedPhone>>;
            whatsapp: (loginId: string, uri: string, user?: User) => Promise<SdkResponse<MaskedPhone>>;
            email: (loginId: string, uri: string, user?: User) => Promise<SdkResponse<MaskedEmail>>;
        }>;
        signUpOrIn: Deliveries<{
            sms: (loginId: string, uri: string) => Promise<SdkResponse<MaskedPhone>>;
            whatsapp: (loginId: string, uri: string) => Promise<SdkResponse<MaskedPhone>>;
            email: (loginId: string, uri: string) => Promise<SdkResponse<MaskedEmail>>;
        }>;
        update: {
            email: <T_2 extends boolean>(loginId: string, email: string, URI?: string, token?: string, updateOptions?: UpdateOptions<T_2>) => Promise<SdkResponse<MaskedEmail>>;
            phone: DeliveriesPhone<(<T_3 extends boolean>(loginId: string, phone: string, URI?: string, token?: string, updateOptions?: UpdateOptions<T_3>) => Promise<SdkResponse<MaskedPhone>>)>;
        };
    };
    enchantedLink: {
        verify: (token: string) => Promise<SdkResponse<never>>;
        signIn: EnchantedLinkSignInFn;
        signUpOrIn: EnchantedLinkSignInFn;
        signUp: EnchantedLinkSignUpFn;
        waitForSession: (pendingRef: string, config?: WaitForSessionConfig) => Promise<SdkResponse<JWTResponse>>;
        update: {
            email: <T_4 extends boolean>(loginId: string, email: string, URI?: string, token?: string, updateOptions?: UpdateOptions<T_4>) => Promise<SdkResponse<EnchantedLinkResponse>>;
        };
    };
    oauth: {
        start: ((provider: string, redirectUrl?: string, loginOptions?: LoginOptions, token?: string) => Promise<SdkResponse<ResponseData>>) & Providers<StartFn>;
        exchange: (code: string) => Promise<SdkResponse<JWTResponse>>;
    };
    saml: {
        start: (tenantIdOrEmail: string, redirectUrl?: string, loginOptions?: LoginOptions, token?: string) => Promise<SdkResponse<URLResponse>>;
        exchange: (code: string) => Promise<SdkResponse<JWTResponse>>;
    };
    totp: {
        signUp: (loginId: string, user?: User) => Promise<SdkResponse<TOTPResponse>>;
        verify: (loginId: string, code: string, loginOptions?: LoginOptions, token?: string) => Promise<SdkResponse<JWTResponse>>;
        update: (loginId: string, token?: string) => Promise<SdkResponse<TOTPResponse>>;
    };
    webauthn: {
        signUp: {
            start: (loginId: string, origin: string, name: string) => Promise<SdkResponse<WebAuthnStartResponse>>;
            finish: (transactionId: string, response: string) => Promise<SdkResponse<JWTResponse>>;
        };
        signIn: {
            start: (loginId: string, origin: string, loginOptions?: LoginOptions, token?: string) => Promise<SdkResponse<WebAuthnStartResponse>>;
            finish: (transactionId: string, response: string) => Promise<SdkResponse<JWTResponse>>;
        };
        signUpOrIn: {
            start: (loginId: string, origin: string) => Promise<SdkResponse<WebAuthnStartResponse>>;
        };
        update: {
            start: (loginId: string, origin: string, token: string) => Promise<SdkResponse<WebAuthnStartResponse>>;
            finish: (transactionId: string, response: string) => Promise<SdkResponse<ResponseData>>;
        };
    };
    password: {
        signUp: (loginId: string, password: string, user?: User) => Promise<SdkResponse<JWTResponse>>;
        signIn: (loginId: string, password: string) => Promise<SdkResponse<JWTResponse>>;
        sendReset: (loginId: string, redirectUrl?: string) => Promise<SdkResponse<PasswordResetResponse>>;
        update: (loginId: string, newPassword: string, token?: string) => Promise<SdkResponse<never>>;
        replace: (loginId: string, oldPassword: string, newPassword: string) => Promise<SdkResponse<JWTResponse>>;
        policy: () => Promise<SdkResponse<PasswordPolicyResponse>>;
    };
    flow: {
        start: (flowId: string, options?: Options, conditionInteractionId?: string, interactionId?: string, version?: number, componentsVersion?: string, input?: FlowInput) => Promise<SdkResponse<FlowResponse>>;
        next: (executionId: string, stepId: string, interactionId: string, version?: number, componentsVersion?: string, input?: FlowInput) => Promise<SdkResponse<FlowResponse>>;
    };
    refresh: (token?: string) => Promise<SdkResponse<JWTResponse>>;
    selectTenant: (tenantId: string, token?: string) => Promise<SdkResponse<JWTResponse>>;
    logout: (token?: string) => Promise<SdkResponse<never>>;
    logoutAll: (token?: string) => Promise<SdkResponse<never>>;
    me: (token?: string) => Promise<SdkResponse<UserResponse>>;
    isJwtExpired: (token: string) => boolean;
    getTenants: (token: string) => string[];
    getJwtPermissions: (token: string, tenant?: string) => string[];
    getJwtRoles: (token: string, tenant?: string) => string[];
    httpClient: HttpClient;
}) & {
    DeliveryMethods: {
        readonly email: DeliveryEmail.email;
        readonly sms: DeliveryPhone.sms;
        readonly whatsapp: DeliveryPhone.whatsapp;
    };
};

/** Type to restrict to valid delivery methods */
type DeliveryMethod = keyof typeof DeliveryMethods;
/** Type to restrict to valid OAuth providers */
type OAuthProvider = keyof typeof OAuthProviders;

export { DeliveryMethod, EnchantedLinkResponse, ExchangeAccessKeyResponse, FlowAction, FlowResponse, FlowStatus, HTTPMethods, _default$1 as HttpStatusCodes, JWTResponse, LoginOptions, OAuthProvider, RequestConfig, ResponseData, SdkFnWrapper, SdkResponse, TOTPResponse, URLResponse, UserResponse, _default as default, transformResponse, wrapWith };
