{"version":3,"file":"index.cjs.js","sources":["../../lib/constants.ts","../../lib/helpers.ts","../../lib/management/paths.ts","../../lib/management/user.ts","../../lib/management/project.ts","../../lib/management/tenant.ts","../../lib/management/jwt.ts","../../lib/management/permission.ts","../../lib/management/role.ts","../../lib/management/group.ts","../../lib/management/sso.ts","../../lib/management/accesskey.ts","../../lib/management/flow.ts","../../lib/management/theme.ts","../../lib/management/audit.ts","../../lib/management/authz.ts","../../lib/fetch-polyfill.ts","../../lib/index.ts","../../lib/management/index.ts","../../lib/errors.ts"],"sourcesContent":["// eslint-disable-next-line import/prefer-default-export\n/** Refresh JWT cookie name */\nexport const refreshTokenCookieName = 'DSR';\n/** Session JWT cookie name */\nexport const sessionTokenCookieName = 'DS';\n/** The key of the tenants claims in the claims map */\nexport const authorizedTenantsClaimName = 'tenants';\n/** The key of the permissions claims in the claims map either under tenant or top level */\nexport const permissionsClaimName = 'permissions';\n/** The key of the roles claims in the claims map either under tenant or top level */\nexport const rolesClaimName = 'roles';\n","import type { SdkFnWrapper } from '@descope/core-js-sdk';\nimport { authorizedTenantsClaimName, refreshTokenCookieName } from './constants';\nimport { AuthenticationInfo } from './types';\n\n/**\n * Generate a cookie string from given parameters\n * @param name name of the cookie\n * @param value value of cookie that must be already encoded\n * @param options any options to put on the cookie like cookieDomain, cookieMaxAge, cookiePath\n * @returns Cookie string with all options on the string\n */\nconst generateCookie = (name: string, value: string, options?: Record<string, string | number>) =>\n  `${name}=${value}; Domain=${options?.cookieDomain || ''}; Max-Age=${\n    options?.cookieMaxAge || ''\n  }; Path=${options?.cookiePath || '/'}; HttpOnly; SameSite=Strict`;\n\n/**\n * Parse the cookie string and return the value of the cookie\n * @param cookie the raw cookie string\n * @param name the name of the cookie to get value for\n * @returns the value of the given cookie\n */\nconst getCookieValue = (cookie: string | null | undefined, name: string) => {\n  const match = cookie?.match(RegExp(`(?:^|;\\\\s*)${name}=([^;]*)`));\n  return match ? match[1] : null;\n};\n\n// eslint-disable-next-line import/prefer-default-export\n/**\n * Add cookie generation to core-js functions.\n * @param fn the function we are wrapping\n * @returns Wrapped function with cookie generation\n */\nexport const withCookie: SdkFnWrapper<{ refreshJwt?: string; cookies?: string[] }> =\n  (fn) =>\n  async (...args) => {\n    const resp = await fn(...args);\n\n    // istanbul ignore next\n    if (!resp.data) {\n      return resp;\n    }\n\n    // eslint-disable-next-line prefer-const\n    let { refreshJwt, ...rest } = resp.data;\n    const cookies: string[] = [];\n\n    if (!refreshJwt) {\n      if (resp.response?.headers.get('set-cookie')) {\n        refreshJwt = getCookieValue(\n          resp.response?.headers.get('set-cookie'),\n          refreshTokenCookieName,\n        );\n        cookies.push(resp.response?.headers.get('set-cookie')!);\n      }\n    } else {\n      cookies.push(generateCookie(refreshTokenCookieName, refreshJwt, rest));\n    }\n\n    return { ...resp, data: { ...resp.data, refreshJwt, cookies } };\n  };\n\n/**\n * Get the claim (used for permissions or roles) for a given tenant or top level if tenant is empty\n * @param authInfo The parsed authentication info from the JWT\n * @param claim name of the claim\n * @param tenant tenant to retrieve the claim for\n * @returns the claim for the given tenant or top level if tenant is empty\n */\nexport function getAuthorizationClaimItems(\n  authInfo: AuthenticationInfo,\n  claim: string,\n  tenant?: string,\n): string[] {\n  const value = tenant\n    ? authInfo.token[authorizedTenantsClaimName]?.[tenant]?.[claim]\n    : authInfo.token[claim];\n  return Array.isArray(value) ? value : [];\n}\n\n/**\n * Check if the user is associated with the given tenant\n * @param authInfo The parsed authentication info from the JWT\n * @param tenant tenant to check if user is associated with\n * @returns true if user is associated with the tenant\n */\nexport function isUserAssociatedWithTenant(authInfo: AuthenticationInfo, tenant: string): boolean {\n  return !!authInfo.token[authorizedTenantsClaimName]?.[tenant];\n}\n","/** API paths for the Descope service Management APIs */\nexport default {\n  user: {\n    create: '/v1/mgmt/user/create',\n    createBatch: '/v1/mgmt/user/create/batch',\n    update: '/v1/mgmt/user/update',\n    delete: '/v1/mgmt/user/delete',\n    deleteAllTestUsers: '/v1/mgmt/user/test/delete/all',\n    load: '/v1/mgmt/user',\n    logout: '/v1/mgmt/user/logout',\n    search: '/v1/mgmt/user/search',\n    getProviderToken: '/v1/mgmt/user/provider/token',\n    updateStatus: '/v1/mgmt/user/update/status',\n    updateLoginId: '/v1/mgmt/user/update/loginid',\n    updateEmail: '/v1/mgmt/user/update/email',\n    updatePhone: '/v1/mgmt/user/update/phone',\n    updateDisplayName: '/v1/mgmt/user/update/name',\n    updatePicture: '/v1/mgmt/user/update/picture',\n    updateCustomAttribute: '/v1/mgmt/user/update/customAttribute',\n    setRole: '/v1/mgmt/user/update/role/set',\n    addRole: '/v1/mgmt/user/update/role/add',\n    removeRole: '/v1/mgmt/user/update/role/remove',\n    addTenant: '/v1/mgmt/user/update/tenant/add',\n    removeTenant: '/v1/mgmt/user/update/tenant/remove',\n    setPassword: '/v1/mgmt/user/password/set',\n    expirePassword: '/v1/mgmt/user/password/expire',\n    generateOTPForTest: '/v1/mgmt/tests/generate/otp',\n    generateMagicLinkForTest: '/v1/mgmt/tests/generate/magiclink',\n    generateEnchantedLinkForTest: '/v1/mgmt/tests/generate/enchantedlink',\n    generateEmbeddedLink: '/v1/mgmt/user/signin/embeddedlink',\n  },\n  project: {\n    updateName: '/v1/mgmt/project/update/name',\n    clone: '/v1/mgmt/project/clone',\n  },\n  accessKey: {\n    create: '/v1/mgmt/accesskey/create',\n    load: '/v1/mgmt/accesskey',\n    search: '/v1/mgmt/accesskey/search',\n    update: '/v1/mgmt/accesskey/update',\n    deactivate: '/v1/mgmt/accesskey/deactivate',\n    activate: '/v1/mgmt/accesskey/activate',\n    delete: '/v1/mgmt/accesskey/delete',\n  },\n  tenant: {\n    create: '/v1/mgmt/tenant/create',\n    update: '/v1/mgmt/tenant/update',\n    delete: '/v1/mgmt/tenant/delete',\n    load: '/v1/mgmt/tenant',\n    loadAll: '/v1/mgmt/tenant/all',\n    searchAll: '/v1/mgmt/tenant/search',\n  },\n  sso: {\n    settings: '/v1/mgmt/sso/settings',\n    metadata: '/v1/mgmt/sso/metadata',\n    mapping: '/v1/mgmt/sso/mapping',\n  },\n  jwt: {\n    update: '/v1/mgmt/jwt/update',\n  },\n  permission: {\n    create: '/v1/mgmt/permission/create',\n    update: '/v1/mgmt/permission/update',\n    delete: '/v1/mgmt/permission/delete',\n    loadAll: '/v1/mgmt/permission/all',\n  },\n  role: {\n    create: '/v1/mgmt/role/create',\n    update: '/v1/mgmt/role/update',\n    delete: '/v1/mgmt/role/delete',\n    loadAll: '/v1/mgmt/role/all',\n  },\n  flow: {\n    list: '/v1/mgmt/flow/list',\n    export: '/v1/mgmt/flow/export',\n    import: '/v1/mgmt/flow/import',\n  },\n  theme: {\n    export: '/v1/mgmt/theme/export',\n    import: '/v1/mgmt/theme/import',\n  },\n  group: {\n    loadAllGroups: '/v1/mgmt/group/all',\n    loadAllGroupsForMember: '/v1/mgmt/group/member/all',\n    loadAllGroupMembers: '/v1/mgmt/group/members',\n  },\n  audit: {\n    search: '/v1/mgmt/audit/search',\n  },\n  authz: {\n    schemaSave: '/v1/mgmt/authz/schema/save',\n    schemaDelete: '/v1/mgmt/authz/schema/delete',\n    schemaLoad: '/v1/mgmt/authz/schema/load',\n    nsSave: '/v1/mgmt/authz/ns/save',\n    nsDelete: '/v1/mgmt/authz/ns/delete',\n    rdSave: '/v1/mgmt/authz/rd/save',\n    rdDelete: '/v1/mgmt/authz/rd/delete',\n    reCreate: '/v1/mgmt/authz/re/create',\n    reDelete: '/v1/mgmt/authz/re/delete',\n    reDeleteResources: '/v1/mgmt/authz/re/deleteresources',\n    hasRelations: '/v1/mgmt/authz/re/has',\n    who: '/v1/mgmt/authz/re/who',\n    resource: '/v1/mgmt/authz/re/resource',\n    targets: '/v1/mgmt/authz/re/targets',\n    targetAll: '/v1/mgmt/authz/re/targetall',\n  },\n};\n","import { SdkResponse, transformResponse, UserResponse, LoginOptions } from '@descope/core-js-sdk';\nimport {\n  ProviderTokenResponse,\n  AssociatedTenant,\n  GenerateEnchantedLinkForTestResponse,\n  GenerateMagicLinkForTestResponse,\n  GenerateOTPForTestResponse,\n  GenerateEmbeddedLinkResponse,\n  AttributesTypes,\n  UserStatus,\n  User,\n  InviteBatchResponse,\n} from './types';\nimport { CoreSdk, DeliveryMethodForTestUser } from '../types';\nimport apiPaths from './paths';\n\ntype SingleUserResponse = {\n  user: UserResponse;\n};\n\ntype MultipleUsersResponse = {\n  users: UserResponse[];\n};\n\nconst withUser = (sdk: CoreSdk, managementKey?: string) => ({\n  create: (\n    loginId: string,\n    email?: string,\n    phone?: string,\n    displayName?: string,\n    roles?: string[],\n    userTenants?: AssociatedTenant[],\n    customAttributes?: Record<string, AttributesTypes>,\n    picture?: string,\n    verifiedEmail?: boolean,\n    verifiedPhone?: boolean,\n    givenName?: string,\n    middleName?: string,\n    familyName?: string,\n    additionalLoginIds?: string[],\n  ): Promise<SdkResponse<UserResponse>> =>\n    transformResponse<SingleUserResponse, UserResponse>(\n      sdk.httpClient.post(\n        apiPaths.user.create,\n        {\n          loginId,\n          email,\n          phone,\n          displayName,\n          givenName,\n          middleName,\n          familyName,\n          roleNames: roles,\n          userTenants,\n          customAttributes,\n          picture,\n          verifiedEmail,\n          verifiedPhone,\n          additionalLoginIds,\n        },\n        { token: managementKey },\n      ),\n      (data) => data.user,\n    ),\n  /**\n   * Create a new test user.\n   * The loginID is required and will determine what the user will use to sign in.\n   * Make sure the login id is unique for test. All other fields are optional.\n   *\n   * You can later generate OTP, Magic link and enchanted link to use in the test without the need\n   * of 3rd party messaging services.\n   * Those users are not counted as part of the monthly active users\n   * @returns The UserResponse if found, throws otherwise.\n   */\n  createTestUser: (\n    loginId: string,\n    email?: string,\n    phone?: string,\n    displayName?: string,\n    roles?: string[],\n    userTenants?: AssociatedTenant[],\n    customAttributes?: Record<string, AttributesTypes>,\n    picture?: string,\n    verifiedEmail?: boolean,\n    verifiedPhone?: boolean,\n    givenName?: string,\n    middleName?: string,\n    familyName?: string,\n    additionalLoginIds?: string[],\n  ): Promise<SdkResponse<UserResponse>> =>\n    transformResponse<SingleUserResponse, UserResponse>(\n      sdk.httpClient.post(\n        apiPaths.user.create,\n        {\n          loginId,\n          email,\n          phone,\n          displayName,\n          givenName,\n          middleName,\n          familyName,\n          roleNames: roles,\n          userTenants,\n          test: true,\n          customAttributes,\n          picture,\n          verifiedEmail,\n          verifiedPhone,\n          additionalLoginIds,\n        },\n        { token: managementKey },\n      ),\n      (data) => data.user,\n    ),\n  invite: (\n    loginId: string,\n    email?: string,\n    phone?: string,\n    displayName?: string,\n    roles?: string[],\n    userTenants?: AssociatedTenant[],\n    customAttributes?: Record<string, AttributesTypes>,\n    picture?: string,\n    verifiedEmail?: boolean,\n    verifiedPhone?: boolean,\n    inviteUrl?: string,\n    sendMail?: boolean, // send invite via mail, default is according to project settings\n    sendSMS?: boolean, // send invite via text message, default is according to project settings\n    givenName?: string,\n    middleName?: string,\n    familyName?: string,\n    additionalLoginIds?: string[],\n  ): Promise<SdkResponse<UserResponse>> =>\n    transformResponse<SingleUserResponse, UserResponse>(\n      sdk.httpClient.post(\n        apiPaths.user.create,\n        {\n          loginId,\n          email,\n          phone,\n          displayName,\n          givenName,\n          middleName,\n          familyName,\n          roleNames: roles,\n          userTenants,\n          invite: true,\n          customAttributes,\n          picture,\n          verifiedEmail,\n          verifiedPhone,\n          inviteUrl,\n          sendMail,\n          sendSMS,\n          additionalLoginIds,\n        },\n        { token: managementKey },\n      ),\n      (data) => data.user,\n    ),\n  inviteBatch: (\n    users: User[],\n    inviteUrl?: string,\n    sendMail?: boolean, // send invite via mail, default is according to project settings\n    sendSMS?: boolean, // send invite via text message, default is according to project settings\n  ): Promise<SdkResponse<InviteBatchResponse>> =>\n    transformResponse<InviteBatchResponse, InviteBatchResponse>(\n      sdk.httpClient.post(\n        apiPaths.user.createBatch,\n        {\n          users,\n          invite: true,\n          inviteUrl,\n          sendMail,\n          sendSMS,\n        },\n        { token: managementKey },\n      ),\n      (data) => data,\n    ),\n  update: (\n    loginId: string,\n    email?: string,\n    phone?: string,\n    displayName?: string,\n    roles?: string[],\n    userTenants?: AssociatedTenant[],\n    customAttributes?: Record<string, AttributesTypes>,\n    picture?: string,\n    verifiedEmail?: boolean,\n    verifiedPhone?: boolean,\n    givenName?: string,\n    middleName?: string,\n    familyName?: string,\n    additionalLoginIds?: string[],\n  ): Promise<SdkResponse<UserResponse>> =>\n    transformResponse<SingleUserResponse, UserResponse>(\n      sdk.httpClient.post(\n        apiPaths.user.update,\n        {\n          loginId,\n          email,\n          phone,\n          displayName,\n          givenName,\n          middleName,\n          familyName,\n          roleNames: roles,\n          userTenants,\n          customAttributes,\n          picture,\n          verifiedEmail,\n          verifiedPhone,\n          additionalLoginIds,\n        },\n        { token: managementKey },\n      ),\n      (data) => data.user,\n    ),\n  delete: (loginId: string): Promise<SdkResponse<never>> =>\n    transformResponse(\n      sdk.httpClient.post(apiPaths.user.delete, { loginId }, { token: managementKey }),\n    ),\n  /**\n   * Delete all test users in the project.\n   */\n  deleteAllTestUsers: (): Promise<SdkResponse<never>> =>\n    transformResponse(\n      sdk.httpClient.delete(apiPaths.user.deleteAllTestUsers, { token: managementKey }),\n    ),\n  load: (loginId: string): Promise<SdkResponse<UserResponse>> =>\n    transformResponse<SingleUserResponse, UserResponse>(\n      sdk.httpClient.get(apiPaths.user.load, {\n        queryParams: { loginId },\n        token: managementKey,\n      }),\n      (data) => data.user,\n    ),\n  /**\n   * Load an existing user by user ID. The ID can be found\n   * on the user's JWT.\n   * @param userId load a user by this user ID field\n   * @returns The UserResponse if found, throws otherwise.\n   */\n  loadByUserId: (userId: string): Promise<SdkResponse<UserResponse>> =>\n    transformResponse<SingleUserResponse, UserResponse>(\n      sdk.httpClient.get(apiPaths.user.load, {\n        queryParams: { userId },\n        token: managementKey,\n      }),\n      (data) => data.user,\n    ),\n  /**\n   * Logout a user from all devices by the login ID\n   * @param loginId logout user by login ID\n   * @returns The UserResponse if found, throws otherwise.\n   */\n  logoutUser: (loginId: string): Promise<SdkResponse<never>> =>\n    transformResponse(\n      sdk.httpClient.post(apiPaths.user.logout, { loginId }, { token: managementKey }),\n    ),\n  /**\n   * Logout a user from all devices by user ID. The ID can be found\n   * on the user's JWT.\n   * @param userId Logout a user from all devices by this user ID field\n   * @returns The UserResponse if found, throws otherwise.\n   */\n  logoutUserByUserId: (userId: string): Promise<SdkResponse<never>> =>\n    transformResponse(\n      sdk.httpClient.post(apiPaths.user.logout, { userId }, { token: managementKey }),\n    ),\n  /**\n   * Search all users. Results can be filtered according to tenants and/or\n   * roles, and also paginated used the limit and page parameters.\n   * @param tenantIds optional list of tenant IDs to filter by\n   * @param roles optional list of roles to filter by\n   * @param limit optionally limit the response, leave out for default limit\n   * @param page optionally paginate over the response\n   * @param testUsersOnly optionally filter only test users\n   * @param withTestUser optionally include test users in search\n   * @returns An array of UserResponse found by the query\n   */\n  searchAll: (\n    tenantIds?: string[],\n    roles?: string[],\n    limit?: number,\n    page?: number,\n    testUsersOnly?: boolean,\n    withTestUser?: boolean,\n    customAttributes?: Record<string, AttributesTypes>,\n    statuses?: UserStatus[],\n    emails?: string[],\n    phones?: string[],\n  ): Promise<SdkResponse<UserResponse[]>> =>\n    transformResponse<MultipleUsersResponse, UserResponse[]>(\n      sdk.httpClient.post(\n        apiPaths.user.search,\n        {\n          tenantIds,\n          roleNames: roles,\n          limit,\n          page,\n          testUsersOnly,\n          withTestUser,\n          customAttributes,\n          statuses,\n          emails,\n          phones,\n        },\n        { token: managementKey },\n      ),\n      (data) => data.users,\n    ),\n  /**\n   * Get the provider token for the given login ID.\n   * Only users that logged-in using social providers will have token.\n   * Note: The 'Manage tokens from provider' setting must be enabled.\n   * @param loginId the login ID of the user\n   * @param provider the provider name (google, facebook, etc.).\n   * @returns The ProviderTokenResponse of the given user and provider\n   */\n  getProviderToken: (\n    loginId: string,\n    provider: string,\n  ): Promise<SdkResponse<ProviderTokenResponse>> =>\n    transformResponse<ProviderTokenResponse>(\n      sdk.httpClient.get(apiPaths.user.getProviderToken, {\n        queryParams: { loginId, provider },\n        token: managementKey,\n      }),\n      (data) => data,\n    ),\n  activate: (loginId: string): Promise<SdkResponse<UserResponse>> =>\n    transformResponse<SingleUserResponse, UserResponse>(\n      sdk.httpClient.post(\n        apiPaths.user.updateStatus,\n        { loginId, status: 'enabled' },\n        { token: managementKey },\n      ),\n      (data) => data.user,\n    ),\n  deactivate: (loginId: string): Promise<SdkResponse<UserResponse>> =>\n    transformResponse<SingleUserResponse, UserResponse>(\n      sdk.httpClient.post(\n        apiPaths.user.updateStatus,\n        { loginId, status: 'disabled' },\n        { token: managementKey },\n      ),\n      (data) => data.user,\n    ),\n  updateLoginId: (loginId: string, newLoginId?: string): Promise<SdkResponse<UserResponse>> =>\n    transformResponse<SingleUserResponse, UserResponse>(\n      sdk.httpClient.post(\n        apiPaths.user.updateLoginId,\n        { loginId, newLoginId },\n        { token: managementKey },\n      ),\n      (data) => data.user,\n    ),\n  updateEmail: (\n    loginId: string,\n    email: string,\n    isVerified: boolean,\n  ): Promise<SdkResponse<UserResponse>> =>\n    transformResponse<SingleUserResponse, UserResponse>(\n      sdk.httpClient.post(\n        apiPaths.user.updateEmail,\n        { loginId, email, verified: isVerified },\n        { token: managementKey },\n      ),\n      (data) => data.user,\n    ),\n  updatePhone: (\n    loginId: string,\n    phone: string,\n    isVerified: boolean,\n  ): Promise<SdkResponse<UserResponse>> =>\n    transformResponse<SingleUserResponse, UserResponse>(\n      sdk.httpClient.post(\n        apiPaths.user.updatePhone,\n        { loginId, phone, verified: isVerified },\n        { token: managementKey },\n      ),\n      (data) => data.user,\n    ),\n  updateDisplayName: (\n    loginId: string,\n    displayName?: string,\n    givenName?: string,\n    middleName?: string,\n    familyName?: string,\n  ): Promise<SdkResponse<UserResponse>> =>\n    transformResponse<SingleUserResponse, UserResponse>(\n      sdk.httpClient.post(\n        apiPaths.user.updateDisplayName,\n        { loginId, displayName, givenName, middleName, familyName },\n        { token: managementKey },\n      ),\n      (data) => data.user,\n    ),\n  updatePicture: (loginId: string, picture: string): Promise<SdkResponse<UserResponse>> =>\n    transformResponse<SingleUserResponse, UserResponse>(\n      sdk.httpClient.post(\n        apiPaths.user.updatePicture,\n        { loginId, picture },\n        { token: managementKey },\n      ),\n      (data) => data.user,\n    ),\n  updateCustomAttribute: (\n    loginId: string,\n    attributeKey: string,\n    attributeValue: AttributesTypes,\n  ): Promise<SdkResponse<UserResponse>> =>\n    transformResponse<SingleUserResponse, UserResponse>(\n      sdk.httpClient.post(\n        apiPaths.user.updateCustomAttribute,\n        { loginId, attributeKey, attributeValue },\n        { token: managementKey },\n      ),\n      (data) => data.user,\n    ),\n  setRoles: (loginId: string, roles: string[]): Promise<SdkResponse<UserResponse>> =>\n    transformResponse<SingleUserResponse, UserResponse>(\n      sdk.httpClient.post(\n        apiPaths.user.setRole,\n        { loginId, roleNames: roles },\n        { token: managementKey },\n      ),\n      (data) => data.user,\n    ),\n  addRoles: (loginId: string, roles: string[]): Promise<SdkResponse<UserResponse>> =>\n    transformResponse<SingleUserResponse, UserResponse>(\n      sdk.httpClient.post(\n        apiPaths.user.addRole,\n        { loginId, roleNames: roles },\n        { token: managementKey },\n      ),\n      (data) => data.user,\n    ),\n  removeRoles: (loginId: string, roles: string[]): Promise<SdkResponse<UserResponse>> =>\n    transformResponse<SingleUserResponse, UserResponse>(\n      sdk.httpClient.post(\n        apiPaths.user.removeRole,\n        { loginId, roleNames: roles },\n        { token: managementKey },\n      ),\n      (data) => data.user,\n    ),\n  addTenant: (loginId: string, tenantId: string): Promise<SdkResponse<UserResponse>> =>\n    transformResponse<SingleUserResponse, UserResponse>(\n      sdk.httpClient.post(apiPaths.user.addTenant, { loginId, tenantId }, { token: managementKey }),\n      (data) => data.user,\n    ),\n  removeTenant: (loginId: string, tenantId: string): Promise<SdkResponse<UserResponse>> =>\n    transformResponse<SingleUserResponse, UserResponse>(\n      sdk.httpClient.post(\n        apiPaths.user.removeTenant,\n        { loginId, tenantId },\n        { token: managementKey },\n      ),\n      (data) => data.user,\n    ),\n  setTenantRoles: (\n    loginId: string,\n    tenantId: string,\n    roles: string[],\n  ): Promise<SdkResponse<UserResponse>> =>\n    transformResponse<SingleUserResponse, UserResponse>(\n      sdk.httpClient.post(\n        apiPaths.user.setRole,\n        { loginId, tenantId, roleNames: roles },\n        { token: managementKey },\n      ),\n      (data) => data.user,\n    ),\n  addTenantRoles: (\n    loginId: string,\n    tenantId: string,\n    roles: string[],\n  ): Promise<SdkResponse<UserResponse>> =>\n    transformResponse<SingleUserResponse, UserResponse>(\n      sdk.httpClient.post(\n        apiPaths.user.addRole,\n        { loginId, tenantId, roleNames: roles },\n        { token: managementKey },\n      ),\n      (data) => data.user,\n    ),\n  removeTenantRoles: (\n    loginId: string,\n    tenantId: string,\n    roles: string[],\n  ): Promise<SdkResponse<UserResponse>> =>\n    transformResponse<SingleUserResponse, UserResponse>(\n      sdk.httpClient.post(\n        apiPaths.user.removeRole,\n        { loginId, tenantId, roleNames: roles },\n        { token: managementKey },\n      ),\n      (data) => data.user,\n    ),\n\n  /**\n   * Generate OTP for the given login ID of a test user.\n   * Choose the selected delivery method for verification.\n   * Returns the code for the login (exactly as it sent via Email or SMS)\n   * This is useful when running tests and don't want to use 3rd party messaging services\n   *\n   * @param deliveryMethod optional DeliveryMethod\n   * @param loginId login ID of a test user\n   * @param loginOptions optional LoginOptions - can be provided to set custom claims to the generated jwt.\n   * @returns GenerateOTPForTestResponse which includes the loginId and the OTP code\n   */\n  generateOTPForTestUser: (\n    deliveryMethod: DeliveryMethodForTestUser,\n    loginId: string,\n    loginOptions?: LoginOptions,\n  ): Promise<SdkResponse<GenerateOTPForTestResponse>> =>\n    transformResponse<GenerateOTPForTestResponse>(\n      sdk.httpClient.post(\n        apiPaths.user.generateOTPForTest,\n        { deliveryMethod, loginId, loginOptions },\n        { token: managementKey },\n      ),\n      (data) => data,\n    ),\n\n  /**\n   * Generate Magic Link for the given login ID of a test user.\n   * Choose the selected delivery method for verification.\n   * It returns the link for the login (exactly as it sent via Email)\n   * This is useful when running tests and don't want to use 3rd party messaging services\n   *\n   * @param deliveryMethod optional DeliveryMethod\n   * @param loginId login ID of a test user\n   * @param uri optional redirect uri which will be used instead of any global configuration.\n   * @param loginOptions optional LoginOptions - can be provided to set custom claims to the generated jwt.\n   * @returns GenerateMagicLinkForTestResponse which includes the loginId and the magic link\n   */\n  generateMagicLinkForTestUser: (\n    deliveryMethod: DeliveryMethodForTestUser,\n    loginId: string,\n    uri: string,\n    loginOptions?: LoginOptions,\n  ): Promise<SdkResponse<GenerateMagicLinkForTestResponse>> =>\n    transformResponse<GenerateMagicLinkForTestResponse>(\n      sdk.httpClient.post(\n        apiPaths.user.generateMagicLinkForTest,\n        { deliveryMethod, loginId, URI: uri, loginOptions },\n        { token: managementKey },\n      ),\n      (data) => data,\n    ),\n\n  /**\n   * Generate Enchanted Link for the given login ID of a test user.\n   * It returns the link for the login (exactly as it sent via Email)\n   * and pendingRef which is used to poll for a valid session\n   * This is useful when running tests and don't want to use 3rd party messaging services\n   *\n   * @param loginId login ID of a test user\n   * @param uri optional redirect uri which will be used instead of any global configuration.\n   * @param loginOptions optional LoginOptions - can be provided to set custom claims to the generated jwt.\n   * @returns GenerateEnchantedLinkForTestResponse which includes the loginId, the enchanted link and the pendingRef\n   */\n  generateEnchantedLinkForTestUser: (\n    loginId: string,\n    uri: string,\n    loginOptions?: LoginOptions,\n  ): Promise<SdkResponse<GenerateEnchantedLinkForTestResponse>> =>\n    transformResponse<GenerateEnchantedLinkForTestResponse>(\n      sdk.httpClient.post(\n        apiPaths.user.generateEnchantedLinkForTest,\n        { loginId, URI: uri, loginOptions },\n        { token: managementKey },\n      ),\n      (data) => data,\n    ),\n\n  generateEmbeddedLink: (\n    loginId: string,\n    customClaims?: Record<string, any>,\n  ): Promise<SdkResponse<GenerateEmbeddedLinkResponse>> =>\n    transformResponse<GenerateEmbeddedLinkResponse>(\n      sdk.httpClient.post(\n        apiPaths.user.generateEmbeddedLink,\n        { loginId, customClaims },\n        { token: managementKey },\n      ),\n      (data) => data,\n    ),\n\n  /**\n   * Set password for the given login ID of user.\n   * Note: The password will automatically be set as expired.\n   * The user will not be able to log-in with this password, and will be required to replace it on next login.\n   * See also: expirePassword\n   * @param loginId login ID of a test user\n   * @param password The password to set for the user\n   */\n  setPassword: (loginId: string, password: string): Promise<SdkResponse<never>> =>\n    transformResponse<never>(\n      sdk.httpClient.post(\n        apiPaths.user.setPassword,\n        { loginId, password },\n        { token: managementKey },\n      ),\n      (data) => data,\n    ),\n\n  /**\n   * Expire password for the given login ID.\n   * Note: user sign-in with an expired password, the user will get an error with code.\n   * Use the `ResetPassword` or `ReplacePassword` methods to reset/replace the password.\n   * @param loginId login ID of a test user\n   */\n  expirePassword: (loginId: string): Promise<SdkResponse<never>> =>\n    transformResponse<never>(\n      sdk.httpClient.post(apiPaths.user.expirePassword, { loginId }, { token: managementKey }),\n      (data) => data,\n    ),\n});\n\nexport default withUser;\n","import { SdkResponse, transformResponse } from '@descope/core-js-sdk';\nimport { CoreSdk } from '../types';\nimport apiPaths from './paths';\nimport { NewProjectResponse, ProjectTag } from './types';\n\nconst withProject = (sdk: CoreSdk, managementKey?: string) => ({\n  /**\n   * Update the current project name.\n   * @param name The new name of the project\n   */\n  updateName: (name: string): Promise<SdkResponse<never>> =>\n    transformResponse(\n      sdk.httpClient.post(\n        apiPaths.project.updateName,\n        {\n          name,\n        },\n        { token: managementKey },\n      ),\n    ),\n  /**\n   * Clone the current project, including its settings and configurations.\n   *  - This action is supported only with a pro license or above.\n   *  - Users, tenants and access keys are not cloned.\n   * @param name The name of the new project\n   * @param tag The tag of the new project\n   * @returns The new project details (name, id, tag, and settings)\n   */\n  clone: (name: string, tag?: ProjectTag): Promise<SdkResponse<NewProjectResponse>> =>\n    transformResponse(\n      sdk.httpClient.post(\n        apiPaths.project.clone,\n        {\n          name,\n          tag,\n        },\n        { token: managementKey },\n      ),\n    ),\n});\n\nexport default withProject;\n","import { SdkResponse, transformResponse } from '@descope/core-js-sdk';\nimport { CoreSdk } from '../types';\nimport apiPaths from './paths';\nimport { CreateTenantResponse, Tenant, AttributesTypes } from './types';\n\ntype MultipleTenantResponse = {\n  tenants: Tenant[];\n};\n\nconst withTenant = (sdk: CoreSdk, managementKey?: string) => ({\n  create: (\n    name: string,\n    selfProvisioningDomains?: string[],\n    customAttributes?: Record<string, AttributesTypes>,\n  ): Promise<SdkResponse<CreateTenantResponse>> =>\n    transformResponse(\n      sdk.httpClient.post(\n        apiPaths.tenant.create,\n        { name, selfProvisioningDomains, customAttributes },\n        { token: managementKey },\n      ),\n    ),\n  createWithId: (\n    id: string,\n    name: string,\n    selfProvisioningDomains?: string[],\n    customAttributes?: Record<string, AttributesTypes>,\n  ): Promise<SdkResponse<never>> =>\n    transformResponse(\n      sdk.httpClient.post(\n        apiPaths.tenant.create,\n        { id, name, selfProvisioningDomains, customAttributes },\n        { token: managementKey },\n      ),\n    ),\n  update: (\n    id: string,\n    name: string,\n    selfProvisioningDomains?: string[],\n    customAttributes?: Record<string, AttributesTypes>,\n  ): Promise<SdkResponse<never>> =>\n    transformResponse(\n      sdk.httpClient.post(\n        apiPaths.tenant.update,\n        { id, name, selfProvisioningDomains, customAttributes },\n        { token: managementKey },\n      ),\n    ),\n  delete: (id: string): Promise<SdkResponse<never>> =>\n    transformResponse(\n      sdk.httpClient.post(apiPaths.tenant.delete, { id }, { token: managementKey }),\n    ),\n  load: (id: string): Promise<SdkResponse<Tenant>> =>\n    transformResponse<Tenant, Tenant>(\n      sdk.httpClient.get(apiPaths.tenant.load, {\n        queryParams: { id },\n        token: managementKey,\n      }),\n      (data) => data,\n    ),\n  loadAll: (): Promise<SdkResponse<Tenant[]>> =>\n    transformResponse<MultipleTenantResponse, Tenant[]>(\n      sdk.httpClient.get(apiPaths.tenant.loadAll, {\n        token: managementKey,\n      }),\n      (data) => data.tenants,\n    ),\n  searchAll: (\n    ids?: string[],\n    names?: string[],\n    selfProvisioningDomains?: string[],\n    customAttributes?: Record<string, AttributesTypes>,\n  ): Promise<SdkResponse<Tenant[]>> =>\n    transformResponse<MultipleTenantResponse, Tenant[]>(\n      sdk.httpClient.post(\n        apiPaths.tenant.searchAll,\n        {\n          tenantIds: ids,\n          tenantNames: names,\n          tenantSelfProvisioningDomains: selfProvisioningDomains,\n          customAttributes,\n        },\n        { token: managementKey },\n      ),\n      (data) => data.tenants,\n    ),\n});\n\nexport default withTenant;\n","import { SdkResponse, transformResponse } from '@descope/core-js-sdk';\nimport { CoreSdk } from '../types';\nimport apiPaths from './paths';\nimport { UpdateJWTResponse } from './types';\n\nconst withJWT = (sdk: CoreSdk, managementKey?: string) => ({\n  update: (\n    jwt: string,\n    customClaims?: Record<string, any>,\n  ): Promise<SdkResponse<UpdateJWTResponse>> =>\n    transformResponse(\n      sdk.httpClient.post(apiPaths.jwt.update, { jwt, customClaims }, { token: managementKey }),\n    ),\n});\n\nexport default withJWT;\n","import { SdkResponse, transformResponse } from '@descope/core-js-sdk';\nimport { CoreSdk } from '../types';\nimport apiPaths from './paths';\nimport { Permission } from './types';\n\ntype MultiplePermissionResponse = {\n  permissions: Permission[];\n};\n\nconst withPermission = (sdk: CoreSdk, managementKey?: string) => ({\n  create: (name: string, description?: string): Promise<SdkResponse<never>> =>\n    transformResponse(\n      sdk.httpClient.post(\n        apiPaths.permission.create,\n        { name, description },\n        { token: managementKey },\n      ),\n    ),\n  update: (name: string, newName: string, description?: string): Promise<SdkResponse<never>> =>\n    transformResponse(\n      sdk.httpClient.post(\n        apiPaths.permission.update,\n        { name, newName, description },\n        { token: managementKey },\n      ),\n    ),\n  delete: (name: string): Promise<SdkResponse<never>> =>\n    transformResponse(\n      sdk.httpClient.post(apiPaths.permission.delete, { name }, { token: managementKey }),\n    ),\n  loadAll: (): Promise<SdkResponse<Permission[]>> =>\n    transformResponse<MultiplePermissionResponse, Permission[]>(\n      sdk.httpClient.get(apiPaths.permission.loadAll, {\n        token: managementKey,\n      }),\n      (data) => data.permissions,\n    ),\n});\n\nexport default withPermission;\n","import { SdkResponse, transformResponse } from '@descope/core-js-sdk';\nimport { CoreSdk } from '../types';\nimport apiPaths from './paths';\nimport { Role } from './types';\n\ntype MultipleRoleResponse = {\n  roles: Role[];\n};\n\nconst withRole = (sdk: CoreSdk, managementKey?: string) => ({\n  create: (\n    name: string,\n    description?: string,\n    permissionNames?: string[],\n  ): Promise<SdkResponse<never>> =>\n    transformResponse(\n      sdk.httpClient.post(\n        apiPaths.role.create,\n        { name, description, permissionNames },\n        { token: managementKey },\n      ),\n    ),\n  update: (\n    name: string,\n    newName: string,\n    description?: string,\n    permissionNames?: string[],\n  ): Promise<SdkResponse<never>> =>\n    transformResponse(\n      sdk.httpClient.post(\n        apiPaths.role.update,\n        { name, newName, description, permissionNames },\n        { token: managementKey },\n      ),\n    ),\n  delete: (name: string): Promise<SdkResponse<never>> =>\n    transformResponse(\n      sdk.httpClient.post(apiPaths.role.delete, { name }, { token: managementKey }),\n    ),\n  loadAll: (): Promise<SdkResponse<Role[]>> =>\n    transformResponse<MultipleRoleResponse, Role[]>(\n      sdk.httpClient.get(apiPaths.role.loadAll, {\n        token: managementKey,\n      }),\n      (data) => data.roles,\n    ),\n});\n\nexport default withRole;\n","import { SdkResponse, transformResponse } from '@descope/core-js-sdk';\nimport { CoreSdk } from '../types';\nimport apiPaths from './paths';\nimport { Group } from './types';\n\nconst withGroup = (sdk: CoreSdk, managementKey?: string) => ({\n  /**\n   * Load all groups for a specific tenant id.\n   * @param tenantId Tenant ID to load groups from.\n   * @returns Group[] list of groups\n   */\n  loadAllGroups: (tenantId: string): Promise<SdkResponse<Group[]>> =>\n    transformResponse<Group[]>(\n      sdk.httpClient.post(apiPaths.group.loadAllGroups, { tenantId }, { token: managementKey }),\n    ),\n\n  /**\n   * Load all groups for the provided user IDs or login IDs.\n   * @param tenantId Tenant ID to load groups from.\n   * @param userIds Optional List of user IDs, with the format of \"U2J5ES9S8TkvCgOvcrkpzUgVTEBM\" (example), which can be found on the user's JWT.\n   * @param loginIds Optional List of login IDs, how the user identifies when logging in.\n   * @returns Group[] list of groups\n   */\n  loadAllGroupsForMember: (\n    tenantId: string,\n    userIds: string[],\n    loginIds: string[],\n  ): Promise<SdkResponse<Group[]>> =>\n    transformResponse<Group[]>(\n      sdk.httpClient.post(\n        apiPaths.group.loadAllGroupsForMember,\n        { tenantId, loginIds, userIds },\n        { token: managementKey },\n      ),\n    ),\n\n  /**\n   * Load all members of the provided group id.\n   * @param tenantId Tenant ID to load groups from.\n   * @param groupId Group ID to load members for.\n   * @returns Group[] list of groups\n   */\n  loadAllGroupMembers: (tenantId: string, groupId: string): Promise<SdkResponse<Group[]>> =>\n    transformResponse<Group[]>(\n      sdk.httpClient.post(\n        apiPaths.group.loadAllGroupMembers,\n        { tenantId, groupId },\n        { token: managementKey },\n      ),\n    ),\n});\n\nexport default withGroup;\n","import { SdkResponse, transformResponse } from '@descope/core-js-sdk';\nimport { CoreSdk } from '../types';\nimport apiPaths from './paths';\nimport { RoleMappings, AttributeMapping, SSOSettingsResponse } from './types';\n\nconst withSSOSettings = (sdk: CoreSdk, managementKey?: string) => ({\n  getSettings: (tenantId: string): Promise<SdkResponse<SSOSettingsResponse>> =>\n    transformResponse<SSOSettingsResponse>(\n      sdk.httpClient.get(apiPaths.sso.settings, {\n        queryParams: { tenantId },\n        token: managementKey,\n      }),\n      (data) => data,\n    ),\n  deleteSettings: (tenantId: string): Promise<SdkResponse<never>> =>\n    transformResponse(\n      sdk.httpClient.delete(apiPaths.sso.settings, {\n        queryParams: { tenantId },\n        token: managementKey,\n      }),\n    ),\n  configureSettings: (\n    tenantId: string,\n    idpURL: string,\n    idpCert: string,\n    entityId: string,\n    redirectURL: string,\n    domains: string[],\n  ): Promise<SdkResponse<never>> =>\n    transformResponse(\n      sdk.httpClient.post(\n        apiPaths.sso.settings,\n        { tenantId, idpURL, entityId, idpCert, redirectURL, domains },\n        { token: managementKey },\n      ),\n    ),\n  configureMetadata: (\n    tenantId: string,\n    idpMetadataURL: string,\n    redirectURL: string,\n    domains: string[],\n  ): Promise<SdkResponse<never>> =>\n    transformResponse(\n      sdk.httpClient.post(\n        apiPaths.sso.metadata,\n        { tenantId, idpMetadataURL, redirectURL, domains },\n        { token: managementKey },\n      ),\n    ),\n  configureMapping: (\n    tenantId: string,\n    roleMappings?: RoleMappings,\n    attributeMapping?: AttributeMapping,\n  ): Promise<SdkResponse<never>> =>\n    transformResponse(\n      sdk.httpClient.post(\n        apiPaths.sso.mapping,\n        { tenantId, roleMappings, attributeMapping },\n        { token: managementKey },\n      ),\n    ),\n});\n\nexport default withSSOSettings;\n","import { SdkResponse, transformResponse } from '@descope/core-js-sdk';\nimport { CoreSdk } from '../types';\nimport apiPaths from './paths';\nimport { AccessKey, AssociatedTenant, CreatedAccessKeyResponse } from './types';\n\ntype SingleKeyResponse = {\n  key: AccessKey;\n};\n\ntype MultipleKeysResponse = {\n  keys: AccessKey[];\n};\n\nconst withAccessKey = (sdk: CoreSdk, managementKey?: string) => ({\n  /**\n   * Create a new access key for a project.\n   * @param name Access key name\n   * @param expireTime When the access key expires. Keep at 0 to make it indefinite.\n   * @param roles Optional roles in the project. Does not apply for multi-tenants\n   * @param keyTenants Optional associated tenants for this key and its roles for each.\n   * @returns A newly created key and its cleartext. Make sure to save the cleartext securely.\n   */\n  create: (\n    name: string,\n    expireTime: number,\n    roles?: string[],\n    keyTenants?: AssociatedTenant[],\n  ): Promise<SdkResponse<CreatedAccessKeyResponse>> =>\n    transformResponse(\n      sdk.httpClient.post(\n        apiPaths.accessKey.create,\n        { name, expireTime, roleNames: roles, keyTenants },\n        { token: managementKey },\n      ),\n    ),\n  /**\n   * Load an access key.\n   * @param id Access key ID to load\n   * @returns The loaded access key.\n   */\n  load: (id: string): Promise<SdkResponse<AccessKey>> =>\n    transformResponse<SingleKeyResponse, AccessKey>(\n      sdk.httpClient.get(apiPaths.accessKey.load, {\n        queryParams: { id },\n        token: managementKey,\n      }),\n      (data) => data.key,\n    ),\n  /**\n   * Search all access keys\n   * @param tenantIds Optional tenant ID filter to apply on the search results\n   * @returns An array of found access keys\n   */\n  searchAll: (tenantIds?: string[]): Promise<SdkResponse<AccessKey[]>> =>\n    transformResponse<MultipleKeysResponse, AccessKey[]>(\n      sdk.httpClient.post(apiPaths.accessKey.search, { tenantIds }, { token: managementKey }),\n      (data) => data.keys,\n    ),\n  /**\n   * Update an access key.\n   * @param id Access key ID to load\n   * @param name The updated access key name\n   * @returns The updated access key\n   */\n  update: (id: string, name: string): Promise<SdkResponse<AccessKey>> =>\n    transformResponse<SingleKeyResponse, AccessKey>(\n      sdk.httpClient.post(apiPaths.accessKey.update, { id, name }, { token: managementKey }),\n      (data) => data.key,\n    ),\n  /**\n   * Deactivate an access key. Deactivated access keys cannot be used until they are\n   * activated again.\n   * @param id Access key ID to deactivate\n   */\n  deactivate: (id: string): Promise<SdkResponse<never>> =>\n    transformResponse(\n      sdk.httpClient.post(apiPaths.accessKey.deactivate, { id }, { token: managementKey }),\n    ),\n  /**\n   * Activate an access key. Only deactivated access keys can be activated again.\n   * @param id Access key ID to activate\n   */\n  activate: (id: string): Promise<SdkResponse<never>> =>\n    transformResponse(\n      sdk.httpClient.post(apiPaths.accessKey.activate, { id }, { token: managementKey }),\n    ),\n  /**\n   * Delete an access key. IMPORTANT: This cannot be undone. Use carefully.\n   * @param id Access key ID to delete\n   */\n  delete: (id: string): Promise<SdkResponse<never>> =>\n    transformResponse(\n      sdk.httpClient.post(apiPaths.accessKey.delete, { id }, { token: managementKey }),\n    ),\n});\n\nexport default withAccessKey;\n","import { SdkResponse, transformResponse } from '@descope/core-js-sdk';\nimport { CoreSdk } from '../types';\nimport apiPaths from './paths';\nimport { FlowResponse, FlowsResponse, Screen, Flow } from './types';\n\nconst WithFlow = (sdk: CoreSdk, managementKey?: string) => ({\n  list: (): Promise<SdkResponse<FlowsResponse>> =>\n    transformResponse(sdk.httpClient.post(apiPaths.flow.list, {}, { token: managementKey })),\n  export: (flowId: string): Promise<SdkResponse<FlowResponse>> =>\n    transformResponse(\n      sdk.httpClient.post(apiPaths.flow.export, { flowId }, { token: managementKey }),\n    ),\n  import: (flowId: string, flow: Flow, screens?: Screen[]): Promise<SdkResponse<FlowResponse>> =>\n    transformResponse(\n      sdk.httpClient.post(\n        apiPaths.flow.import,\n        { flowId, flow, screens },\n        { token: managementKey },\n      ),\n    ),\n});\n\nexport default WithFlow;\n","import { SdkResponse, transformResponse } from '@descope/core-js-sdk';\nimport { CoreSdk } from '../types';\nimport apiPaths from './paths';\nimport { Theme, ThemeResponse } from './types';\n\nconst WithTheme = (sdk: CoreSdk, managementKey?: string) => ({\n  export: (): Promise<SdkResponse<ThemeResponse>> =>\n    transformResponse(sdk.httpClient.post(apiPaths.theme.export, {}, { token: managementKey })),\n  import: (theme: Theme): Promise<SdkResponse<ThemeResponse>> =>\n    transformResponse(\n      sdk.httpClient.post(apiPaths.theme.import, { theme }, { token: managementKey }),\n    ),\n});\n\nexport default WithTheme;\n","import { SdkResponse, transformResponse } from '@descope/core-js-sdk';\nimport { CoreSdk } from '../types';\nimport apiPaths from './paths';\nimport { AuditSearchOptions, AuditRecord } from './types';\n\nconst WithAudit = (sdk: CoreSdk, managementKey?: string) => ({\n  /**\n   * Search the audit trail for up to last 30 days based on given optional parameters\n   * @param searchOptions to filter which audit records to return\n   * @returns the audit records array\n   */\n  search: (searchOptions: AuditSearchOptions): Promise<SdkResponse<AuditRecord[]>> => {\n    const body = { ...searchOptions, externalIds: searchOptions.loginIds };\n    delete body.loginIds;\n    return transformResponse(\n      sdk.httpClient.post(apiPaths.audit.search, body, { token: managementKey }),\n      (data) =>\n        data?.audits.map((a) => {\n          const res = {\n            ...a,\n            occurred: parseFloat(a.occurred),\n            loginIds: a.externalIds,\n          };\n          delete res.externalIds;\n          return res;\n        }),\n    );\n  },\n});\n\nexport default WithAudit;\n","import { SdkResponse, transformResponse } from '@descope/core-js-sdk';\nimport { CoreSdk } from '../types';\nimport apiPaths from './paths';\nimport {\n  AuthzSchema,\n  AuthzNamespace,\n  AuthzRelationDefinition,\n  AuthzRelation,\n  AuthzRelationQuery,\n} from './types';\n\nconst WithAuthz = (sdk: CoreSdk, managementKey?: string) => ({\n  /**\n   * Save (create or update) the given schema.\n   * In case of update, will update only given namespaces and will not delete namespaces unless upgrade flag is true.\n   * Schema name can be used for projects to track versioning.\n   *\n   * @param schema the schema to save\n   * @param upgrade should we upgrade existing schema or ignore any namespace not provided\n   * @returns standard success or failure response\n   */\n  saveSchema: (schema: AuthzSchema, upgrade: boolean): Promise<SdkResponse<never>> =>\n    transformResponse(\n      sdk.httpClient.post(apiPaths.authz.schemaSave, { schema, upgrade }, { token: managementKey }),\n    ),\n  /**\n   * Delete the schema for the project which will also delete all relations.\n   *\n   * @returns standard success or failure response\n   */\n  deleteSchema: (): Promise<SdkResponse<never>> =>\n    transformResponse(\n      sdk.httpClient.post(apiPaths.authz.schemaDelete, {}, { token: managementKey }),\n    ),\n  /**\n   * Load the schema for the project.\n   *\n   * @returns the schema associated with the project\n   */\n  loadSchema: (): Promise<SdkResponse<AuthzSchema>> =>\n    transformResponse(\n      sdk.httpClient.post(apiPaths.authz.schemaLoad, {}, { token: managementKey }),\n      (data) => data.schema,\n    ),\n  /**\n   * Save (create or update) the given namespace.\n   * Will not delete relation definitions not mentioned in the namespace.\n   *\n   * @param namespace the namespace to save\n   * @param oldName if we are changing the namespace name, what was the old name we are updating.\n   * @param schemaName optional and used to track the current schema version.\n   * @returns standard success or failure response\n   */\n  saveNamespace: (\n    namespace: AuthzNamespace,\n    oldName?: string,\n    schemaName?: string,\n  ): Promise<SdkResponse<never>> =>\n    transformResponse(\n      sdk.httpClient.post(\n        apiPaths.authz.nsSave,\n        { namespace, oldName, schemaName },\n        { token: managementKey },\n      ),\n    ),\n  /**\n   * Delete the given namespace.\n   * Will also delete the relevant relations.\n   *\n   * @param name to delete.\n   * @param schemaName optional and used to track the current schema version.\n   * @returns standard success or failure response\n   */\n  deleteNamespace: (name: string, schemaName?: string): Promise<SdkResponse<never>> =>\n    transformResponse(\n      sdk.httpClient.post(apiPaths.authz.nsDelete, { name, schemaName }, { token: managementKey }),\n    ),\n  /**\n   * Save (create or update) the given relation definition.\n   *\n   * @param relationDefinition rd to save.\n   * @param namespace that it belongs to.\n   * @param oldName if we are changing the relation definition name, what was the old name we are updating.\n   * @param schemaName optional and used to track the current schema version.\n   * @returns standard success or failure response\n   */\n  saveRelationDefinition: (\n    relationDefinition: AuthzRelationDefinition,\n    namespace: string,\n    oldName?: string,\n    schemaName?: string,\n  ): Promise<SdkResponse<never>> =>\n    transformResponse(\n      sdk.httpClient.post(\n        apiPaths.authz.rdSave,\n        { relationDefinition, namespace, oldName, schemaName },\n        { token: managementKey },\n      ),\n    ),\n  /**\n   * Delete the given relation definition.\n   * Will also delete the relevant relations.\n   *\n   * @param name to delete.\n   * @param namespace it belongs to.\n   * @param schemaName optional and used to track the current schema version.\n   * @returns standard success or failure response\n   */\n  deleteRelationDefinition: (\n    name: string,\n    namespace: string,\n    schemaName?: string,\n  ): Promise<SdkResponse<never>> =>\n    transformResponse(\n      sdk.httpClient.post(\n        apiPaths.authz.rdDelete,\n        { name, namespace, schemaName },\n        { token: managementKey },\n      ),\n    ),\n  /**\n   * Create the given relations.\n   *\n   * @param relations to create.\n   * @returns standard success or failure response\n   */\n  createRelations: (relations: AuthzRelation[]): Promise<SdkResponse<never>> =>\n    transformResponse(\n      sdk.httpClient.post(apiPaths.authz.reCreate, { relations }, { token: managementKey }),\n    ),\n  /**\n   * Delete the given relations.\n   *\n   * @param relations to delete.\n   * @returns standard success or failure response\n   */\n  deleteRelations: (relations: AuthzRelation[]): Promise<SdkResponse<never>> =>\n    transformResponse(\n      sdk.httpClient.post(apiPaths.authz.reDelete, { relations }, { token: managementKey }),\n    ),\n  /**\n   * Delete the relations for the given resources.\n   *\n   * @param resources resources to delete relations for.\n   * @returns standard success or failure response\n   */\n  deleteRelationsForResources: (resources: string[]): Promise<SdkResponse<never>> =>\n    transformResponse(\n      sdk.httpClient.post(\n        apiPaths.authz.reDeleteResources,\n        { resources },\n        { token: managementKey },\n      ),\n    ),\n  /**\n   * Query relations to see what relations exists.\n   *\n   * @param relationQueries array of relation queries to check.\n   * @returns array of relation query responses with the boolean flag indicating if relation exists\n   */\n  hasRelations: (\n    relationQueries: AuthzRelationQuery[],\n  ): Promise<SdkResponse<AuthzRelationQuery[]>> =>\n    transformResponse(\n      sdk.httpClient.post(\n        apiPaths.authz.hasRelations,\n        { relationQueries },\n        { token: managementKey },\n      ),\n      (data) => data.relationQueries,\n    ),\n  /**\n   * List all the users that have the given relation definition to the given resource.\n   *\n   * @param resource The resource we are checking\n   * @param relationDefinition The relation definition we are querying\n   * @param namespace The namespace for the relation definition\n   * @returns array of users who have the given relation definition\n   */\n  whoCanAccess: (\n    resource: string,\n    relationDefinition: string,\n    namespace: string,\n  ): Promise<SdkResponse<string[]>> =>\n    transformResponse(\n      sdk.httpClient.post(\n        apiPaths.authz.who,\n        { resource, relationDefinition, namespace },\n        { token: managementKey },\n      ),\n      (data) => data.targets,\n    ),\n  /**\n   * Return the list of all defined relations (not recursive) on the given resource.\n   *\n   * @param resource The resource we are checking\n   * @returns array of relations that exist for the given resource\n   */\n  resourceRelations: (resource: string): Promise<SdkResponse<AuthzRelation[]>> =>\n    transformResponse(\n      sdk.httpClient.post(apiPaths.authz.resource, { resource }, { token: managementKey }),\n      (data) => data.relations,\n    ),\n  /**\n   * Return the list of all defined relations (not recursive) for the given targets.\n   *\n   * @param targets array of targets we want to check\n   * @returns array of relations that exist for the given targets\n   */\n  targetsRelations: (targets: string[]): Promise<SdkResponse<AuthzRelation[]>> =>\n    transformResponse(\n      sdk.httpClient.post(apiPaths.authz.targets, { targets }, { token: managementKey }),\n      (data) => data.relations,\n    ),\n  /**\n   * Return the list of all relations for the given target including derived relations from the schema tree.\n   *\n   * @param target The target to check relations for\n   * @returns array of relations that exist for the given targets\n   */\n  whatCanTargetAccess: (target: string): Promise<SdkResponse<AuthzRelation[]>> =>\n    transformResponse(\n      sdk.httpClient.post(apiPaths.authz.targetAll, { target }, { token: managementKey }),\n      (data) => data.relations,\n    ),\n});\n\nexport default WithAuthz;\n","import { fetch as crossFetch, Headers } from 'cross-fetch';\n\nglobalThis.Headers ??= Headers;\n\nconst highWaterMarkMb = 1024 * 1024 * 30; // 30MB\n\n// we are increasing the response buffer size due to an issue where node-fetch hangs when response is too big\nconst patchedFetch = (...args: Parameters<typeof crossFetch>) => {\n  // we can get Request on the first arg, or RequestInfo on the second arg\n  // we want to make sure we are setting the \"highWaterMark\" so we are doing it on both args\n  args.forEach((arg) => {\n    // eslint-disable-next-line no-param-reassign, @typescript-eslint/no-unused-expressions\n    arg && ((arg as any).highWaterMark ??= highWaterMarkMb);\n  });\n\n  return crossFetch(...args);\n};\n\nexport default patchedFetch as unknown as typeof fetch;\n","import createSdk, { ExchangeAccessKeyResponse, SdkResponse, wrapWith } from '@descope/core-js-sdk';\nimport { JWK, JWTHeaderParameters, KeyLike, errors, importJWK, jwtVerify } from 'jose';\nimport {\n  permissionsClaimName,\n  refreshTokenCookieName,\n  rolesClaimName,\n  sessionTokenCookieName,\n} from './constants';\nimport { getAuthorizationClaimItems, isUserAssociatedWithTenant, withCookie } from './helpers';\nimport withManagement from './management';\nimport { AuthenticationInfo } from './types';\nimport fetch from './fetch-polyfill';\n\ndeclare const BUILD_VERSION: string;\n\n/** Configuration arguments which include the Descope core SDK args and an optional management key */\ntype NodeSdkArgs = Parameters<typeof createSdk>[0] & {\n  managementKey?: string;\n  publicKey?: string;\n};\n\nconst nodeSdk = ({ managementKey, publicKey, ...config }: NodeSdkArgs) => {\n  const coreSdk = createSdk({\n    fetch,\n    ...config,\n    baseHeaders: {\n      ...config.baseHeaders,\n      'x-descope-sdk-name': 'nodejs',\n      'x-descope-sdk-node-version': process?.versions?.node || '',\n      'x-descope-sdk-version': BUILD_VERSION,\n    },\n  });\n\n  const { projectId, logger } = config;\n\n  const keys: Record<string, KeyLike | Uint8Array> = {};\n\n  /** Fetch the public keys (JWKs) from Descope for the configured project */\n  const fetchKeys = async () => {\n    if (publicKey) {\n      try {\n        const parsedKey = JSON.parse(publicKey);\n        const key = await importJWK(parsedKey);\n        return {\n          [parsedKey.kid]: key,\n        };\n      } catch (e) {\n        logger?.error('Failed to parse the provided public key', e);\n        throw new Error(`Failed to parse public key. Error: ${e}`);\n      }\n    }\n\n    const keysWrapper = await coreSdk.httpClient\n      .get(`v2/keys/${projectId}`)\n      .then((resp) => resp.json());\n    const publicKeys: JWK[] = keysWrapper.keys;\n    if (!Array.isArray(publicKeys)) return {};\n    const kidJwksPairs = await Promise.all(\n      publicKeys.map(async (key) => [key.kid, await importJWK(key)]),\n    );\n\n    return kidJwksPairs.reduce(\n      (acc, [kid, jwk]) => (kid ? { ...acc, [kid.toString()]: jwk } : acc),\n      {},\n    );\n  };\n\n  const management = withManagement(coreSdk, managementKey);\n\n  const sdk = {\n    ...coreSdk,\n\n    /**\n     * Provides various APIs for managing a Descope project programmatically. A management key must\n     * be provided as an argument when initializing the SDK to use these APIs. Management keys can be\n     * generated in the Descope console.\n     */\n    management,\n\n    /** Get the key that can validate the given JWT KID in the header. Can retrieve the public key from local cache or from Descope. */\n    async getKey(header: JWTHeaderParameters): Promise<KeyLike | Uint8Array> {\n      if (!header?.kid) throw Error('header.kid must not be empty');\n\n      if (keys[header.kid]) return keys[header.kid];\n\n      // do we need to fetch once or every time?\n      Object.assign(keys, await fetchKeys());\n\n      if (!keys[header.kid]) throw Error('failed to fetch matching key');\n\n      return keys[header.kid];\n    },\n\n    /**\n     * Validate the given JWT with the right key and make sure the issuer is correct\n     * @param jwt the JWT string to parse and validate\n     * @returns AuthenticationInfo with the parsed token and JWT. Will throw an error if validation fails.\n     */\n    async validateJwt(jwt: string): Promise<AuthenticationInfo> {\n      // Do not hard-code the algo because library does not support `None` so all are valid\n      const res = await jwtVerify(jwt, sdk.getKey, { clockTolerance: 5 });\n      const token = res.payload;\n\n      if (token) {\n        token.iss = token.iss?.split('/').pop(); // support both url and project id as issuer\n        if (token.iss !== projectId) {\n          // We must do the verification here, since issuer can be either project ID or URL\n          throw new errors.JWTClaimValidationFailed(\n            'unexpected \"iss\" claim value',\n            'iss',\n            'check_failed',\n          );\n        }\n      }\n\n      return { jwt, token };\n    },\n\n    /**\n     * Validate an active session\n     * @param sessionToken session JWT to validate\n     * @returns AuthenticationInfo promise or throws Error if there is an issue with JWTs\n     */\n    async validateSession(sessionToken: string): Promise<AuthenticationInfo> {\n      if (!sessionToken) throw Error('session token is required for validation');\n\n      try {\n        const token = await sdk.validateJwt(sessionToken);\n        return token;\n      } catch (error) {\n        /* istanbul ignore next */\n        logger?.error('session validation failed', error);\n        throw Error(`session validation failed. Error: ${error}`);\n      }\n    },\n\n    /**\n     * Refresh the session using a refresh token\n     * @param refreshToken refresh JWT to refresh the session with\n     * @returns AuthenticationInfo promise or throws Error if there is an issue with JWTs\n     */\n    async refreshSession(refreshToken: string): Promise<AuthenticationInfo> {\n      if (!refreshToken) throw Error('refresh token is required to refresh a session');\n\n      try {\n        await sdk.validateJwt(refreshToken);\n        const jwtResp = await sdk.refresh(refreshToken);\n        if (jwtResp.ok) {\n          const token = await sdk.validateJwt(jwtResp.data?.sessionJwt);\n          return token;\n        }\n        /* istanbul ignore next */\n        throw Error(jwtResp.error?.errorMessage);\n      } catch (refreshTokenErr) {\n        /* istanbul ignore next */\n        logger?.error('refresh token validation failed', refreshTokenErr);\n        throw Error(`refresh token validation failed, Error: ${refreshTokenErr}`);\n      }\n    },\n\n    /**\n     * Validate session and refresh it if it expired\n     * @param sessionToken session JWT\n     * @param refreshToken refresh JWT\n     * @returns AuthenticationInfo promise or throws Error if there is an issue with JWTs\n     */\n    async validateAndRefreshSession(\n      sessionToken?: string,\n      refreshToken?: string,\n    ): Promise<AuthenticationInfo> {\n      if (!sessionToken && !refreshToken) throw Error('both session and refresh tokens are empty');\n\n      try {\n        const token = await sdk.validateSession(sessionToken);\n        return token;\n      } catch (error) {\n        /* istanbul ignore next */\n        logger?.log(`session validation failed with error ${error} - trying to refresh it`);\n      }\n\n      return sdk.refreshSession(refreshToken);\n    },\n\n    /**\n     * Exchange API key (access key) for a session key\n     * @param accessKey access key to exchange for a session JWT\n     * @returns AuthenticationInfo with session JWT data\n     */\n    async exchangeAccessKey(accessKey: string): Promise<AuthenticationInfo> {\n      if (!accessKey) throw Error('access key must not be empty');\n\n      let resp: SdkResponse<ExchangeAccessKeyResponse>;\n      try {\n        resp = await sdk.accessKey.exchange(accessKey);\n      } catch (error) {\n        logger?.error('failed to exchange access key', error);\n        throw Error(`could not exchange access key - Failed to exchange. Error: ${error}`);\n      }\n\n      const { sessionJwt } = resp.data;\n      if (!sessionJwt) {\n        logger?.error('failed to parse exchange access key response');\n        throw Error('could not exchange access key');\n      }\n\n      try {\n        const token = await sdk.validateJwt(sessionJwt);\n        return token;\n      } catch (error) {\n        logger?.error('failed to parse jwt from access key', error);\n        throw Error(`could not exchange access key - failed to validate jwt. Error: ${error}`);\n      }\n    },\n\n    /**\n     * Make sure that all given permissions exist on the parsed JWT top level claims\n     * @param authInfo JWT parsed info\n     * @param permissions list of permissions to make sure they exist on te JWT claims\n     * @returns true if all permissions exist, false otherwise\n     */\n    validatePermissions(authInfo: AuthenticationInfo, permissions: string[]): boolean {\n      return sdk.validateTenantPermissions(authInfo, '', permissions);\n    },\n\n    /**\n     * Retrieves the permissions from JWT top level claims that match the specified permissions list\n     * @param authInfo JWT parsed info containing the permissions\n     * @param permissions List of permissions to match against the JWT claims\n     * @returns An array of permissions that are both in the JWT claims and the specified list. Returns an empty array if no matches are found\n     */\n    getMatchedPermissions(authInfo: AuthenticationInfo, permissions: string[]): string[] {\n      return sdk.getMatchedTenantPermissions(authInfo, '', permissions);\n    },\n\n    /**\n     * Make sure that all given permissions exist on the parsed JWT tenant claims\n     * @param authInfo JWT parsed info\n     * @param tenant tenant to validate the permissions for\n     * @param permissions list of permissions to make sure they exist on te JWT claims\n     * @returns true if all permissions exist, false otherwise\n     */\n    validateTenantPermissions(\n      authInfo: AuthenticationInfo,\n      tenant: string,\n      permissions: string[],\n    ): boolean {\n      // check if user is associated to the tenant\n      if (tenant && !isUserAssociatedWithTenant(authInfo, tenant)) return false;\n\n      const granted = getAuthorizationClaimItems(authInfo, permissionsClaimName, tenant);\n      return permissions.every((perm) => granted.includes(perm));\n    },\n\n    /**\n     * Retrieves the permissions from JWT tenant claims that match the specified permissions list\n     * @param authInfo JWT parsed info containing the permissions\n     * @param tenant tenant to match the permissions for\n     * @param permissions List of permissions to match against the JWT claims\n     * @returns An array of permissions that are both in the JWT claims and the specified list. Returns an empty array if no matches are found\n     * */\n    getMatchedTenantPermissions(\n      authInfo: AuthenticationInfo,\n      tenant: string,\n      permissions: string[],\n    ): string[] {\n      if (tenant && !isUserAssociatedWithTenant(authInfo, tenant)) return [];\n\n      const granted = getAuthorizationClaimItems(authInfo, permissionsClaimName, tenant);\n      return permissions.filter((perm) => granted.includes(perm));\n    },\n\n    /**\n     * Make sure that all given roles exist on the parsed JWT top level claims\n     * @param authInfo JWT parsed info\n     * @param roles list of roles to make sure they exist on te JWT claims\n     * @returns true if all roles exist, false otherwise\n     */\n    validateRoles(authInfo: AuthenticationInfo, roles: string[]): boolean {\n      return sdk.validateTenantRoles(authInfo, '', roles);\n    },\n\n    /**\n     * Retrieves the roles from JWT top level claims that match the specified roles list\n     * @param authInfo JWT parsed info containing the roles\n     * @param roles List of roles to match against the JWT claims\n     * @returns An array of roles that are both in the JWT claims and the specified list. Returns an empty array if no matches are found\n     */\n    getMatchedRoles(authInfo: AuthenticationInfo, roles: string[]): string[] {\n      return sdk.getMatchedTenantRoles(authInfo, '', roles);\n    },\n\n    /**\n     * Make sure that all given roles exist on the parsed JWT tenant claims\n     * @param authInfo JWT parsed info\n     * @param tenant tenant to validate the roles for\n     * @param roles list of roles to make sure they exist on te JWT claims\n     * @returns true if all roles exist, false otherwise\n     */\n    validateTenantRoles(authInfo: AuthenticationInfo, tenant: string, roles: string[]): boolean {\n      // check if user is associated to the tenant\n      if (tenant && !isUserAssociatedWithTenant(authInfo, tenant)) return false;\n\n      const membership = getAuthorizationClaimItems(authInfo, rolesClaimName, tenant);\n      return roles.every((role) => membership.includes(role));\n    },\n\n    /**\n     * Retrieves the roles from JWT tenant claims that match the specified roles list\n     * @param authInfo JWT parsed info containing the roles\n     * @param tenant tenant to match the roles for\n     * @param roles List of roles to match against the JWT claims\n     * @returns An array of roles that are both in the JWT claims and the specified list. Returns an empty array if no matches are found\n     */\n    getMatchedTenantRoles(authInfo: AuthenticationInfo, tenant: string, roles: string[]): string[] {\n      if (tenant && !isUserAssociatedWithTenant(authInfo, tenant)) return [];\n\n      const membership = getAuthorizationClaimItems(authInfo, rolesClaimName, tenant);\n      return roles.filter((role) => membership.includes(role));\n    },\n  };\n\n  return wrapWith(\n    sdk,\n    [\n      'otp.verify.email',\n      'otp.verify.sms',\n      'otp.verify.whatsapp',\n      'magicLink.verify',\n      'enchantedLink.signUp',\n      'enchantedLink.signIn',\n      'oauth.exchange',\n      'saml.exchange',\n      'totp.verify',\n      'webauthn.signIn.finish',\n      'webauthn.signUp.finish',\n      'refresh',\n    ] as const,\n    withCookie,\n  );\n};\n\n/** Descope SDK client with delivery methods enum.\n *\n * Please see full documentation at {@link https://docs.descope.com/guides Descope Docs}\n * @example Usage\n *\n * ```js\n * import descopeSdk from '@descope/node-sdk';\n *\n * const myProjectId = 'xxx';\n * const sdk = descopeSdk({ projectId: myProjectId });\n *\n * const userLoginId = 'loginId';\n * sdk.otp.signIn.email(userLoginId);\n * const jwtResponse = sdk.otp.verify.email(userLoginId, codeFromEmail);\n * ```\n */\n\nnodeSdk.RefreshTokenCookieName = refreshTokenCookieName;\nnodeSdk.SessionTokenCookieName = sessionTokenCookieName;\n\nexport default nodeSdk;\nexport type {\n  DeliveryMethod,\n  OAuthProvider,\n  ResponseData,\n  SdkResponse,\n  JWTResponse,\n} from '@descope/core-js-sdk';\nexport type { AuthenticationInfo };\nexport { descopeErrors } from './errors';\n","import { CoreSdk } from '../types';\nimport withUser from './user';\nimport withProject from './project';\nimport withTenant from './tenant';\nimport withJWT from './jwt';\nimport withPermission from './permission';\nimport withRole from './role';\nimport withGroup from './group';\nimport withSSOSettings from './sso';\nimport withAccessKey from './accesskey';\nimport WithFlow from './flow';\nimport WithTheme from './theme';\nimport WithAudit from './audit';\nimport WithAuthz from './authz';\n\n/** Constructs a higher level Management API that wraps the functions from code-js-sdk */\nconst withManagement = (sdk: CoreSdk, managementKey?: string) => ({\n  user: withUser(sdk, managementKey),\n  project: withProject(sdk, managementKey),\n  accessKey: withAccessKey(sdk, managementKey),\n  tenant: withTenant(sdk, managementKey),\n  sso: withSSOSettings(sdk, managementKey),\n  jwt: withJWT(sdk, managementKey),\n  permission: withPermission(sdk, managementKey),\n  role: withRole(sdk, managementKey),\n  group: withGroup(sdk, managementKey),\n  flow: WithFlow(sdk, managementKey),\n  theme: WithTheme(sdk, managementKey),\n  audit: WithAudit(sdk, managementKey),\n  authz: WithAuthz(sdk, managementKey),\n});\n\nexport default withManagement;\n","// eslint-disable-next-line import/prefer-default-export\n/** Common Error Codes */\nexport const descopeErrors = {\n  badRequest: 'E011001',\n  missingArguments: 'E011002',\n  invalidRequest: 'E011003',\n  invalidArguments: 'E011004',\n  wrongOTPCode: 'E061102',\n  tooManyOTPAttempts: 'E061103',\n  enchantedLinkPending: 'E062503',\n  userNotFound: 'E062108',\n};\n"],"names":["withCookie","fn","async","args","resp","data","_d","refreshJwt","rest","__rest","cookies","options","push","cookieDomain","cookieMaxAge","cookiePath","_a","response","headers","get","cookie","name","match","RegExp","getCookieValue","_b","_c","Object","assign","getAuthorizationClaimItems","authInfo","claim","tenant","value","token","Array","isArray","isUserAssociatedWithTenant","apiPaths","create","createBatch","update","delete","deleteAllTestUsers","load","logout","search","getProviderToken","updateStatus","updateLoginId","updateEmail","updatePhone","updateDisplayName","updatePicture","updateCustomAttribute","setRole","addRole","removeRole","addTenant","removeTenant","setPassword","expirePassword","generateOTPForTest","generateMagicLinkForTest","generateEnchantedLinkForTest","generateEmbeddedLink","updateName","clone","deactivate","activate","loadAll","searchAll","settings","metadata","mapping","list","export","import","loadAllGroups","loadAllGroupsForMember","loadAllGroupMembers","schemaSave","schemaDelete","schemaLoad","nsSave","nsDelete","rdSave","rdDelete","reCreate","reDelete","reDeleteResources","hasRelations","who","resource","targets","targetAll","withUser","sdk","managementKey","loginId","email","phone","displayName","roles","userTenants","customAttributes","picture","verifiedEmail","verifiedPhone","givenName","middleName","familyName","additionalLoginIds","transformResponse","httpClient","post","roleNames","user","createTestUser","test","invite","inviteUrl","sendMail","sendSMS","inviteBatch","users","queryParams","loadByUserId","userId","logoutUser","logoutUserByUserId","tenantIds","limit","page","testUsersOnly","withTestUser","statuses","emails","phones","provider","status","newLoginId","isVerified","verified","attributeKey","attributeValue","setRoles","addRoles","removeRoles","tenantId","setTenantRoles","addTenantRoles","removeTenantRoles","generateOTPForTestUser","deliveryMethod","loginOptions","generateMagicLinkForTestUser","uri","URI","generateEnchantedLinkForTestUser","customClaims","password","withProject","tag","withTenant","selfProvisioningDomains","createWithId","id","tenants","ids","names","tenantNames","tenantSelfProvisioningDomains","withJWT","jwt","withPermission","description","newName","permissions","withRole","permissionNames","withGroup","userIds","loginIds","groupId","withSSOSettings","getSettings","deleteSettings","configureSettings","idpURL","idpCert","entityId","redirectURL","domains","configureMetadata","idpMetadataURL","configureMapping","roleMappings","attributeMapping","withAccessKey","expireTime","keyTenants","key","keys","WithFlow","flowId","flow","screens","WithTheme","theme","WithAudit","searchOptions","body","externalIds","audits","map","a","res","occurred","parseFloat","WithAuthz","saveSchema","schema","upgrade","deleteSchema","loadSchema","saveNamespace","namespace","oldName","schemaName","deleteNamespace","saveRelationDefinition","relationDefinition","deleteRelationDefinition","createRelations","relations","deleteRelations","deleteRelationsForResources","resources","relationQueries","whoCanAccess","resourceRelations","targetsRelations","whatCanTargetAccess","target","globalThis","Headers","patchedFetch","forEach","arg","highWaterMark","crossFetch","fetch","nodeSdk","publicKey","config","coreSdk","createSdk","baseHeaders","process","versions","node","projectId","logger","management","project","accessKey","sso","permission","role","group","audit","authz","withManagement","header","kid","Error","parsedKey","JSON","parse","importJWK","e","error","publicKeys","then","json","Promise","all","reduce","acc","jwk","toString","fetchKeys","jwtVerify","getKey","clockTolerance","payload","iss","split","pop","errors","JWTClaimValidationFailed","sessionToken","validateJwt","refreshToken","jwtResp","refresh","ok","sessionJwt","errorMessage","refreshTokenErr","validateSession","log","refreshSession","exchange","validatePermissions","validateTenantPermissions","getMatchedPermissions","getMatchedTenantPermissions","granted","every","perm","includes","filter","validateRoles","validateTenantRoles","getMatchedRoles","getMatchedTenantRoles","membership","wrapWith","RefreshTokenCookieName","SessionTokenCookieName","badRequest","missingArguments","invalidRequest","invalidArguments","wrongOTPCode","tooManyOTPAttempts","enchantedLinkPending","userNotFound"],"mappings":"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CEhB,EAAIiB,WAAWC,KACb7E,EAAcC,OACd,CACE4D,UACAC,QACAC,QACAC,cACAO,YACAC,aACAC,aACAK,UAAWb,EACXC,cACAC,mBACAC,UACAC,gBACAC,gBACAI,sBAEF,CAAE9E,MAAOgE,KAEV7F,GAASA,EAAKgH,OAYnBC,eAAgB,CACdnB,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,IAEAC,oBACEhB,EAAIiB,WAAWC,KACb7E,EAAcC,OACd,CACE4D,UACAC,QACAC,QACAC,cACAO,YACAC,aACAC,aACAK,UAAWb,EACXC,cACAe,MAAM,EACNd,mBACAC,UACAC,gBACAC,gBACAI,sBAEF,CAAE9E,MAAOgE,KAEV7F,GAASA,EAAKgH,OAEnBG,OAAQ,CACNrB,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAa,EACAC,EACAC,EACAd,EACAC,EACAC,EACAC,IAEAC,EAAiBA,kBACfhB,EAAIiB,WAAWC,KACb7E,EAAcC,OACd,CACE4D,UACAC,QACAC,QACAC,cACAO,YACAC,aACAC,aACAK,UAAWb,EACXC,cACAgB,QAAQ,EACRf,mBACAC,UACAC,gBACAC,gBACAa,YACAC,WACAC,UACAX,sBAEF,CAAE9E,MAAOgE,KAEV7F,GAASA,EAAKgH,OAEnBO,YAAa,CACXC,EACAJ,EACAC,EACAC,IAEAV,EAAiBA,kBACfhB,EAAIiB,WAAWC,KACb7E,EAAcE,YACd,CACEqF,QACAL,QAAQ,EACRC,YACAC,WACAC,WAEF,CAAEzF,MAAOgE,KAEV7F,GAASA,IAEdoC,OAAQ,CACN0D,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,IAEAC,oBACEhB,EAAIiB,WAAWC,KACb7E,EAAcG,OACd,CACE0D,UACAC,QACAC,QACAC,cACAO,YACAC,aACAC,aACAK,UAAWb,EACXC,cACAC,mBACAC,UACAC,gBACAC,gBACAI,sBAEF,CAAE9E,MAAOgE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"}