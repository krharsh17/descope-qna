import * as _descope_core_js_sdk from '@descope/core-js-sdk';
import _descope_core_js_sdk__default, { DeliveryMethod, UserResponse, SdkResponse, ExchangeAccessKeyResponse } from '@descope/core-js-sdk';
export { DeliveryMethod, JWTResponse, OAuthProvider, ResponseData, SdkResponse } from '@descope/core-js-sdk';
import { JWTHeaderParameters, KeyLike } from 'jose';

/** Parsed JWT token */
interface Token {
    sub?: string;
    exp?: number;
    iss?: string;
    [claim: string]: unknown;
}
/** All information regarding token including the raw JWT, parsed JWT and cookies */
interface AuthenticationInfo {
    jwt: string;
    token: Token;
    cookies?: string[];
}
declare type DeliveryMethodForTestUser = DeliveryMethod | 'Embedded';

/** Represents a tenant association for a User or Access Key. The tenantId is required to denote
 * which tenant the user or access key belongs to. The roleNames array is an optional list of
 * roles for the user or access key in this specific tenant.
 */
declare type AssociatedTenant = {
    tenantId: string;
    roleNames: string[];
};
/** The tenantId of a newly created tenant */
declare type CreateTenantResponse = {
    id: string;
};
/** An access key that can be used to access descope */
declare type AccessKey = {
    id: string;
    name: string;
    expiredTime: number;
    roleNames: string[];
    keyTenants?: AssociatedTenant[];
    status: string;
    createdTime: number;
    expiresTime: number;
    createdBy: string;
    clientId: string;
};
/** Access Key extended details including created key cleartext */
declare type CreatedAccessKeyResponse = {
    key: AccessKey;
    cleartext: string;
};
/** Represents a mapping between a set of groups of users and a role that will be assigned to them */
declare type RoleMapping = {
    groups: string[];
    roleName: string;
};
declare type RoleMappings = RoleMapping[];
/** Represents a mapping between Descope and IDP user attributes */
declare type AttributeMapping = {
    name?: string;
    email?: string;
    phoneNumber?: string;
    group?: string;
};
/** UpdateJWT response with a new JWT value with the added custom claims */
declare type UpdateJWTResponse = {
    jwt: string;
};
/** Represents a tenant in a project. It has an id, a name and an array of
 * self provisioning domains used to associate users with that tenant.
 */
declare type Tenant = {
    id: string;
    name: string;
    selfProvisioningDomains: string[];
};
/** Represents a permission in a project. It has a name and optionally a description.
 * It also has a flag indicating whether it is system default or not.
 */
declare type Permission = {
    name: string;
    description?: string;
    systemDefault: boolean;
};
/** Represents a role in a project. It has a name and optionally a description and
 * a list of permissions it grants.
 */
declare type Role = {
    name: string;
    description?: string;
    permissionNames: string[];
    createdTime: number;
};
/** Represents a group in a project. It has an id and display name and a list of group members. */
declare type Group = {
    id: string;
    display: string;
    members?: GroupMember[];
};
/** Represents a group member. It has loginId, userId and display. */
declare type GroupMember = {
    loginId: string;
    userId: string;
    display: string;
};
declare type Flow = {
    id: string;
    name: string;
    description?: string;
    dsl: any;
    disabled: boolean;
    etag?: string;
};
declare type FlowMetadata = {
    id: string;
    name: string;
    description?: string;
    disabled: boolean;
};
declare type Screen = {
    id: string;
    flowId: string;
    inputs?: any;
    interactions?: any;
    htmlTemplate: any;
};
declare type FlowsResponse = {
    flows: FlowMetadata[];
    total: number;
};
declare type FlowResponse = {
    flow: Flow;
    screens: Screen[];
};
declare type Theme = {
    id: string;
    cssTemplate?: any;
};
declare type ThemeResponse = {
    theme: Theme;
};
declare type GenerateOTPForTestResponse = {
    loginId: string;
    code: string;
};
declare type GenerateMagicLinkForTestResponse = {
    loginId: string;
    link: string;
};
declare type GenerateEnchantedLinkForTestResponse = {
    loginId: string;
    link: string;
    pendingRef: string;
};
declare type GenerateEmbeddedLinkResponse = {
    token: string;
};
declare type AttributesTypes = string | boolean | number;
declare type User = {
    loginId: string;
    email?: string;
    phone?: string;
    displayName?: string;
    roles?: string[];
    userTenants?: AssociatedTenant[];
    customAttributes?: Record<string, AttributesTypes>;
    picture?: string;
    verifiedEmail?: boolean;
    verifiedPhone?: boolean;
    test?: boolean;
    additionalLoginIds?: string[];
};
declare type UserMapping = {
    name: string;
    email: string;
    username: string;
    phoneNumber: string;
    group: string;
};
declare type RoleItem = {
    id: string;
    name: string;
};
declare type GroupsMapping = {
    role: RoleItem;
    groups: string[];
};
declare type SSOSettingsResponse = {
    tenantId: string;
    idpEntityId: string;
    idpSSOUrl: string;
    idpCertificate: string;
    idpMetadataUrl: string;
    spEntityId: string;
    spACSUrl: string;
    spCertificate: string;
    userMapping: UserMapping;
    groupsMapping: GroupsMapping[];
    redirectUrl: string;
    domains: string[];
    domain: string;
};
declare type ProviderTokenResponse = {
    provider: string;
    providerUserId: string;
    accessToken: string;
    expiration: number;
    scopes: string[];
};
declare type UserFailedResponse = {
    failure: string;
    user: UserResponse;
};
declare type InviteBatchResponse = {
    createdUsers: UserResponse[];
    failedUsers: UserFailedResponse[];
};
/**
 * Search options to filter which audit records we should retrieve.
 * All parameters are optional. `From` is currently limited to 30 days.
 */
declare type AuditSearchOptions = {
    userIds?: string[];
    actions?: string[];
    excludedActions?: string[];
    devices?: string[];
    methods?: string[];
    geos?: string[];
    remoteAddresses?: string[];
    loginIds?: string[];
    tenants?: string[];
    noTenants?: boolean;
    text?: string;
    from?: number;
    to?: number;
};
/** Audit record response from the audit trail. Occurred is in milliseconds. */
declare type AuditRecord = {
    projectId: string;
    userId: string;
    action: string;
    occurred: number;
    device: string;
    method: string;
    geo: string;
    remoteAddress: string;
    loginIds: string[];
    tenants: string[];
    data: Record<string, any>;
};
declare type UserStatus = 'enabled' | 'disabled' | 'invited';
declare type AuthzNodeExpressionType = 'self' | 'targetSet' | 'relationLeft' | 'relationRight';
/**
 * AuthzNodeExpression holds the definition of a child node
 */
declare type AuthzNodeExpression = {
    neType: AuthzNodeExpressionType;
    relationDefinition?: string;
    relationDefinitionNamespace?: string;
    targetRelationDefinition?: string;
    targetRelationDefinitionNamespace?: string;
};
declare type AuthzNodeType = 'child' | 'union' | 'intersect' | 'sub';
/**
 * AuthzNode holds the definition of a complex relation definition
 */
declare type AuthzNode = {
    nType: AuthzNodeType;
    children?: AuthzNode[];
    expression?: AuthzNodeExpression;
};
/**
 * AuthzRelationDefinition defines a relation within a namespace
 */
declare type AuthzRelationDefinition = {
    name: string;
    complexDefinition?: AuthzNode;
};
/**
 * AuthzNamespace defines an entity in the authorization schema
 */
declare type AuthzNamespace = {
    name: string;
    relationDefinitions: AuthzRelationDefinition[];
};
/**
 * AuthzSchema holds the full schema (all namespaces) for a project
 */
declare type AuthzSchema = {
    name?: string;
    namespaces: AuthzNamespace[];
};
/**
 * AuthzUserQuery represents a target of a relation for ABAC (query on users)
 */
declare type AuthzUserQuery = {
    tenants?: string[];
    roles?: string[];
    text?: string;
    statuses?: UserStatus[];
    ssoOnly?: boolean;
    withTestUser?: boolean;
    customAttributes?: Record<string, any>;
};
/**
 * AuthzRelation defines a relation between resource and target
 */
declare type AuthzRelation = {
    resource: string;
    relationDefinition: string;
    namespace: string;
    target?: string;
    targetSetResource?: string;
    targetSetRelationDefinition?: string;
    targetSetRelationDefinitionNamespace?: string;
    query?: AuthzUserQuery;
};
/**
 * AuthzRelationQuery queries the service if a given relation exists
 */
declare type AuthzRelationQuery = {
    resource: string;
    relationDefinition: string;
    namespace: string;
    target: string;
    hasRelation?: boolean;
};
declare type NewProjectResponse = {
    projectId: string;
    projectName: string;
    projectSettingsWeb: Record<string, any>;
    authMethodsMagicLink: Record<string, any>;
    authMethodsOTP: Record<string, any>;
    authMethodsSAML: Record<string, any>;
    authMethodsOAuth: Record<string, any>;
    authMethodsWebAuthn: Record<string, any>;
    authMethodsTOTP: Record<string, any>;
    messagingProvidersWeb: Record<string, any>;
    authMethodsEnchantedLink: Record<string, any>;
    authMethodsPassword: Record<string, any>;
    authMethodsOIDCIDP: Record<string, any>;
    authMethodsEmbeddedLink: Record<string, any>;
    tag?: string;
};

/** Common Error Codes */
declare const descopeErrors: {
    badRequest: string;
    missingArguments: string;
    invalidRequest: string;
    invalidArguments: string;
    wrongOTPCode: string;
    tooManyOTPAttempts: string;
    enchantedLinkPending: string;
    userNotFound: string;
};

/** Configuration arguments which include the Descope core SDK args and an optional management key */
declare type NodeSdkArgs = Parameters<typeof _descope_core_js_sdk__default>[0] & {
    managementKey?: string;
    publicKey?: string;
};
declare const nodeSdk: {
    ({ managementKey, publicKey, ...config }: NodeSdkArgs): {
        management: {
            user: {
                create: (loginId: string, email?: string, phone?: string, displayName?: string, roles?: string[], userTenants?: AssociatedTenant[], customAttributes?: Record<string, AttributesTypes>, picture?: string, verifiedEmail?: boolean, verifiedPhone?: boolean, givenName?: string, middleName?: string, familyName?: string, additionalLoginIds?: string[]) => Promise<SdkResponse<_descope_core_js_sdk.UserResponse>>;
                createTestUser: (loginId: string, email?: string, phone?: string, displayName?: string, roles?: string[], userTenants?: AssociatedTenant[], customAttributes?: Record<string, AttributesTypes>, picture?: string, verifiedEmail?: boolean, verifiedPhone?: boolean, givenName?: string, middleName?: string, familyName?: string, additionalLoginIds?: string[]) => Promise<SdkResponse<_descope_core_js_sdk.UserResponse>>;
                invite: (loginId: string, email?: string, phone?: string, displayName?: string, roles?: string[], userTenants?: AssociatedTenant[], customAttributes?: Record<string, AttributesTypes>, picture?: string, verifiedEmail?: boolean, verifiedPhone?: boolean, inviteUrl?: string, sendMail?: boolean, sendSMS?: boolean, givenName?: string, middleName?: string, familyName?: string, additionalLoginIds?: string[]) => Promise<SdkResponse<_descope_core_js_sdk.UserResponse>>;
                inviteBatch: (users: User[], inviteUrl?: string, sendMail?: boolean, sendSMS?: boolean) => Promise<SdkResponse<InviteBatchResponse>>;
                update: (loginId: string, email?: string, phone?: string, displayName?: string, roles?: string[], userTenants?: AssociatedTenant[], customAttributes?: Record<string, AttributesTypes>, picture?: string, verifiedEmail?: boolean, verifiedPhone?: boolean, givenName?: string, middleName?: string, familyName?: string, additionalLoginIds?: string[]) => Promise<SdkResponse<_descope_core_js_sdk.UserResponse>>;
                delete: (loginId: string) => Promise<SdkResponse<never>>;
                deleteAllTestUsers: () => Promise<SdkResponse<never>>;
                load: (loginId: string) => Promise<SdkResponse<_descope_core_js_sdk.UserResponse>>;
                loadByUserId: (userId: string) => Promise<SdkResponse<_descope_core_js_sdk.UserResponse>>;
                logoutUser: (loginId: string) => Promise<SdkResponse<never>>;
                logoutUserByUserId: (userId: string) => Promise<SdkResponse<never>>;
                searchAll: (tenantIds?: string[], roles?: string[], limit?: number, page?: number, testUsersOnly?: boolean, withTestUser?: boolean, customAttributes?: Record<string, AttributesTypes>, statuses?: UserStatus[], emails?: string[], phones?: string[]) => Promise<SdkResponse<_descope_core_js_sdk.UserResponse[]>>;
                getProviderToken: (loginId: string, provider: string) => Promise<SdkResponse<ProviderTokenResponse>>;
                activate: (loginId: string) => Promise<SdkResponse<_descope_core_js_sdk.UserResponse>>;
                deactivate: (loginId: string) => Promise<SdkResponse<_descope_core_js_sdk.UserResponse>>;
                updateLoginId: (loginId: string, newLoginId?: string) => Promise<SdkResponse<_descope_core_js_sdk.UserResponse>>;
                updateEmail: (loginId: string, email: string, isVerified: boolean) => Promise<SdkResponse<_descope_core_js_sdk.UserResponse>>;
                updatePhone: (loginId: string, phone: string, isVerified: boolean) => Promise<SdkResponse<_descope_core_js_sdk.UserResponse>>;
                updateDisplayName: (loginId: string, displayName?: string, givenName?: string, middleName?: string, familyName?: string) => Promise<SdkResponse<_descope_core_js_sdk.UserResponse>>;
                updatePicture: (loginId: string, picture: string) => Promise<SdkResponse<_descope_core_js_sdk.UserResponse>>;
                updateCustomAttribute: (loginId: string, attributeKey: string, attributeValue: AttributesTypes) => Promise<SdkResponse<_descope_core_js_sdk.UserResponse>>;
                setRoles: (loginId: string, roles: string[]) => Promise<SdkResponse<_descope_core_js_sdk.UserResponse>>;
                addRoles: (loginId: string, roles: string[]) => Promise<SdkResponse<_descope_core_js_sdk.UserResponse>>;
                removeRoles: (loginId: string, roles: string[]) => Promise<SdkResponse<_descope_core_js_sdk.UserResponse>>;
                addTenant: (loginId: string, tenantId: string) => Promise<SdkResponse<_descope_core_js_sdk.UserResponse>>;
                removeTenant: (loginId: string, tenantId: string) => Promise<SdkResponse<_descope_core_js_sdk.UserResponse>>;
                setTenantRoles: (loginId: string, tenantId: string, roles: string[]) => Promise<SdkResponse<_descope_core_js_sdk.UserResponse>>;
                addTenantRoles: (loginId: string, tenantId: string, roles: string[]) => Promise<SdkResponse<_descope_core_js_sdk.UserResponse>>;
                removeTenantRoles: (loginId: string, tenantId: string, roles: string[]) => Promise<SdkResponse<_descope_core_js_sdk.UserResponse>>;
                generateOTPForTestUser: (deliveryMethod: DeliveryMethodForTestUser, loginId: string, loginOptions?: _descope_core_js_sdk.LoginOptions) => Promise<SdkResponse<GenerateOTPForTestResponse>>;
                generateMagicLinkForTestUser: (deliveryMethod: DeliveryMethodForTestUser, loginId: string, uri: string, loginOptions?: _descope_core_js_sdk.LoginOptions) => Promise<SdkResponse<GenerateMagicLinkForTestResponse>>;
                generateEnchantedLinkForTestUser: (loginId: string, uri: string, loginOptions?: _descope_core_js_sdk.LoginOptions) => Promise<SdkResponse<GenerateEnchantedLinkForTestResponse>>;
                generateEmbeddedLink: (loginId: string, customClaims?: Record<string, any>) => Promise<SdkResponse<GenerateEmbeddedLinkResponse>>;
                setPassword: (loginId: string, password: string) => Promise<SdkResponse<never>>;
                expirePassword: (loginId: string) => Promise<SdkResponse<never>>;
            };
            project: {
                updateName: (name: string) => Promise<SdkResponse<never>>;
                clone: (name: string, tag?: "production") => Promise<SdkResponse<NewProjectResponse>>;
            };
            accessKey: {
                create: (name: string, expireTime: number, roles?: string[], keyTenants?: AssociatedTenant[]) => Promise<SdkResponse<CreatedAccessKeyResponse>>;
                load: (id: string) => Promise<SdkResponse<AccessKey>>;
                searchAll: (tenantIds?: string[]) => Promise<SdkResponse<AccessKey[]>>;
                update: (id: string, name: string) => Promise<SdkResponse<AccessKey>>;
                deactivate: (id: string) => Promise<SdkResponse<never>>;
                activate: (id: string) => Promise<SdkResponse<never>>;
                delete: (id: string) => Promise<SdkResponse<never>>;
            };
            tenant: {
                create: (name: string, selfProvisioningDomains?: string[], customAttributes?: Record<string, AttributesTypes>) => Promise<SdkResponse<CreateTenantResponse>>;
                createWithId: (id: string, name: string, selfProvisioningDomains?: string[], customAttributes?: Record<string, AttributesTypes>) => Promise<SdkResponse<never>>;
                update: (id: string, name: string, selfProvisioningDomains?: string[], customAttributes?: Record<string, AttributesTypes>) => Promise<SdkResponse<never>>;
                delete: (id: string) => Promise<SdkResponse<never>>;
                load: (id: string) => Promise<SdkResponse<Tenant>>;
                loadAll: () => Promise<SdkResponse<Tenant[]>>;
                searchAll: (ids?: string[], names?: string[], selfProvisioningDomains?: string[], customAttributes?: Record<string, AttributesTypes>) => Promise<SdkResponse<Tenant[]>>;
            };
            sso: {
                getSettings: (tenantId: string) => Promise<SdkResponse<SSOSettingsResponse>>;
                deleteSettings: (tenantId: string) => Promise<SdkResponse<never>>;
                configureSettings: (tenantId: string, idpURL: string, idpCert: string, entityId: string, redirectURL: string, domains: string[]) => Promise<SdkResponse<never>>;
                configureMetadata: (tenantId: string, idpMetadataURL: string, redirectURL: string, domains: string[]) => Promise<SdkResponse<never>>;
                configureMapping: (tenantId: string, roleMappings?: RoleMappings, attributeMapping?: AttributeMapping) => Promise<SdkResponse<never>>;
            };
            jwt: {
                update: (jwt: string, customClaims?: Record<string, any>) => Promise<SdkResponse<UpdateJWTResponse>>;
            };
            permission: {
                create: (name: string, description?: string) => Promise<SdkResponse<never>>;
                update: (name: string, newName: string, description?: string) => Promise<SdkResponse<never>>;
                delete: (name: string) => Promise<SdkResponse<never>>;
                loadAll: () => Promise<SdkResponse<Permission[]>>;
            };
            role: {
                create: (name: string, description?: string, permissionNames?: string[]) => Promise<SdkResponse<never>>;
                update: (name: string, newName: string, description?: string, permissionNames?: string[]) => Promise<SdkResponse<never>>;
                delete: (name: string) => Promise<SdkResponse<never>>;
                loadAll: () => Promise<SdkResponse<Role[]>>;
            };
            group: {
                loadAllGroups: (tenantId: string) => Promise<SdkResponse<Group[]>>;
                loadAllGroupsForMember: (tenantId: string, userIds: string[], loginIds: string[]) => Promise<SdkResponse<Group[]>>;
                loadAllGroupMembers: (tenantId: string, groupId: string) => Promise<SdkResponse<Group[]>>;
            };
            flow: {
                list: () => Promise<SdkResponse<FlowsResponse>>;
                export: (flowId: string) => Promise<SdkResponse<FlowResponse>>;
                import: (flowId: string, flow: Flow, screens?: Screen[]) => Promise<SdkResponse<FlowResponse>>;
            };
            theme: {
                export: () => Promise<SdkResponse<ThemeResponse>>;
                import: (theme: Theme) => Promise<SdkResponse<ThemeResponse>>;
            };
            audit: {
                search: (searchOptions: AuditSearchOptions) => Promise<SdkResponse<AuditRecord[]>>;
            };
            authz: {
                saveSchema: (schema: AuthzSchema, upgrade: boolean) => Promise<SdkResponse<never>>;
                deleteSchema: () => Promise<SdkResponse<never>>;
                loadSchema: () => Promise<SdkResponse<AuthzSchema>>;
                saveNamespace: (namespace: AuthzNamespace, oldName?: string, schemaName?: string) => Promise<SdkResponse<never>>;
                deleteNamespace: (name: string, schemaName?: string) => Promise<SdkResponse<never>>;
                saveRelationDefinition: (relationDefinition: AuthzRelationDefinition, namespace: string, oldName?: string, schemaName?: string) => Promise<SdkResponse<never>>;
                deleteRelationDefinition: (name: string, namespace: string, schemaName?: string) => Promise<SdkResponse<never>>;
                createRelations: (relations: AuthzRelation[]) => Promise<SdkResponse<never>>;
                deleteRelations: (relations: AuthzRelation[]) => Promise<SdkResponse<never>>;
                deleteRelationsForResources: (resources: string[]) => Promise<SdkResponse<never>>;
                hasRelations: (relationQueries: AuthzRelationQuery[]) => Promise<SdkResponse<AuthzRelationQuery[]>>;
                whoCanAccess: (resource: string, relationDefinition: string, namespace: string) => Promise<SdkResponse<string[]>>;
                resourceRelations: (resource: string) => Promise<SdkResponse<AuthzRelation[]>>;
                targetsRelations: (targets: string[]) => Promise<SdkResponse<AuthzRelation[]>>;
                whatCanTargetAccess: (target: string) => Promise<SdkResponse<AuthzRelation[]>>;
            };
        };
        getKey: (header: JWTHeaderParameters) => Promise<KeyLike | Uint8Array>;
        validateJwt: (jwt: string) => Promise<AuthenticationInfo>;
        validateSession: (sessionToken: string) => Promise<AuthenticationInfo>;
        refreshSession: (refreshToken: string) => Promise<AuthenticationInfo>;
        validateAndRefreshSession: (sessionToken?: string, refreshToken?: string) => Promise<AuthenticationInfo>;
        exchangeAccessKey: (accessKey: string) => Promise<AuthenticationInfo>;
        validatePermissions: (authInfo: AuthenticationInfo, permissions: string[]) => boolean;
        getMatchedPermissions: (authInfo: AuthenticationInfo, permissions: string[]) => string[];
        validateTenantPermissions: (authInfo: AuthenticationInfo, tenant: string, permissions: string[]) => boolean;
        getMatchedTenantPermissions: (authInfo: AuthenticationInfo, tenant: string, permissions: string[]) => string[];
        validateRoles: (authInfo: AuthenticationInfo, roles: string[]) => boolean;
        getMatchedRoles: (authInfo: AuthenticationInfo, roles: string[]) => string[];
        validateTenantRoles: (authInfo: AuthenticationInfo, tenant: string, roles: string[]) => boolean;
        getMatchedTenantRoles: (authInfo: AuthenticationInfo, tenant: string, roles: string[]) => string[];
        accessKey: {
            exchange: (accessKey: string) => Promise<SdkResponse<ExchangeAccessKeyResponse>>;
        };
        otp: {
            verify: {
                sms: (loginId: string, code: string) => Promise<SdkResponse<_descope_core_js_sdk.JWTResponse & {
                    refreshJwt?: string;
                    cookies?: string[];
                }>>;
                whatsapp: (loginId: string, code: string) => Promise<SdkResponse<_descope_core_js_sdk.JWTResponse & {
                    refreshJwt?: string;
                    cookies?: string[];
                }>>;
                email: (loginId: string, code: string) => Promise<SdkResponse<_descope_core_js_sdk.JWTResponse & {
                    refreshJwt?: string;
                    cookies?: string[];
                }>>;
            };
            signIn: {
                sms: (loginId: string) => Promise<SdkResponse<{
                    maskedPhone: string;
                }>>;
                whatsapp: (loginId: string) => Promise<SdkResponse<{
                    maskedPhone: string;
                }>>;
                email: (loginId: string) => Promise<SdkResponse<{
                    maskedEmail: string;
                }>>;
            };
            signUp: {
                sms: (loginId: string, user?: {
                    email?: string;
                    name?: string;
                    givenName?: string;
                    middleName?: string;
                    familyName?: string;
                    phone?: string;
                }) => Promise<SdkResponse<{
                    maskedPhone: string;
                }>>;
                whatsapp: (loginId: string, user?: {
                    email?: string;
                    name?: string;
                    givenName?: string;
                    middleName?: string;
                    familyName?: string;
                    phone?: string;
                }) => Promise<SdkResponse<{
                    maskedPhone: string;
                }>>;
                email: (loginId: string, user?: {
                    email?: string;
                    name?: string;
                    givenName?: string;
                    middleName?: string;
                    familyName?: string;
                    phone?: string;
                }) => Promise<SdkResponse<{
                    maskedEmail: string;
                }>>;
            };
            signUpOrIn: {
                sms: (loginId: string) => Promise<SdkResponse<{
                    maskedPhone: string;
                }>>;
                whatsapp: (loginId: string) => Promise<SdkResponse<{
                    maskedPhone: string;
                }>>;
                email: (loginId: string) => Promise<SdkResponse<{
                    maskedEmail: string;
                }>>;
            };
            update: {
                email: <T extends boolean>(loginId: string, email: string, token?: string, updateOptions?: {
                    addToLoginIDs?: T;
                    onMergeUseExisting?: T extends true ? boolean : never;
                }) => Promise<SdkResponse<{
                    maskedEmail: string;
                }>>;
                phone: {
                    sms: <T_1 extends boolean>(loginId: string, phone: string, token?: string, updateOptions?: {
                        addToLoginIDs?: T_1;
                        onMergeUseExisting?: T_1 extends true ? boolean : never;
                    }) => Promise<SdkResponse<{
                        maskedPhone: string;
                    }>>;
                    whatsapp: <T_1 extends boolean>(loginId: string, phone: string, token?: string, updateOptions?: {
                        addToLoginIDs?: T_1;
                        onMergeUseExisting?: T_1 extends true ? boolean : never;
                    }) => Promise<SdkResponse<{
                        maskedPhone: string;
                    }>>;
                };
            };
        };
        magicLink: {
            verify: (token: string) => Promise<SdkResponse<_descope_core_js_sdk.JWTResponse & {
                refreshJwt?: string;
                cookies?: string[];
            }>>;
            signIn: {
                sms: (loginId: string, uri: string) => Promise<SdkResponse<{
                    maskedPhone: string;
                }>>;
                whatsapp: (loginId: string, uri: string) => Promise<SdkResponse<{
                    maskedPhone: string;
                }>>;
                email: (loginId: string, uri: string) => Promise<SdkResponse<{
                    maskedEmail: string;
                }>>;
            };
            signUp: {
                sms: (loginId: string, uri: string, user?: {
                    email?: string;
                    name?: string;
                    givenName?: string;
                    middleName?: string;
                    familyName?: string;
                    phone?: string;
                }) => Promise<SdkResponse<{
                    maskedPhone: string;
                }>>;
                whatsapp: (loginId: string, uri: string, user?: {
                    email?: string;
                    name?: string;
                    givenName?: string;
                    middleName?: string;
                    familyName?: string;
                    phone?: string;
                }) => Promise<SdkResponse<{
                    maskedPhone: string;
                }>>;
                email: (loginId: string, uri: string, user?: {
                    email?: string;
                    name?: string;
                    givenName?: string;
                    middleName?: string;
                    familyName?: string;
                    phone?: string;
                }) => Promise<SdkResponse<{
                    maskedEmail: string;
                }>>;
            };
            signUpOrIn: {
                sms: (loginId: string, uri: string) => Promise<SdkResponse<{
                    maskedPhone: string;
                }>>;
                whatsapp: (loginId: string, uri: string) => Promise<SdkResponse<{
                    maskedPhone: string;
                }>>;
                email: (loginId: string, uri: string) => Promise<SdkResponse<{
                    maskedEmail: string;
                }>>;
            };
            update: {
                email: <T_2 extends boolean>(loginId: string, email: string, URI?: string, token?: string, updateOptions?: {
                    addToLoginIDs?: T_2;
                    onMergeUseExisting?: T_2 extends true ? boolean : never;
                }) => Promise<SdkResponse<{
                    maskedEmail: string;
                }>>;
                phone: {
                    sms: <T_3 extends boolean>(loginId: string, phone: string, URI?: string, token?: string, updateOptions?: {
                        addToLoginIDs?: T_3;
                        onMergeUseExisting?: T_3 extends true ? boolean : never;
                    }) => Promise<SdkResponse<{
                        maskedPhone: string;
                    }>>;
                    whatsapp: <T_3 extends boolean>(loginId: string, phone: string, URI?: string, token?: string, updateOptions?: {
                        addToLoginIDs?: T_3;
                        onMergeUseExisting?: T_3 extends true ? boolean : never;
                    }) => Promise<SdkResponse<{
                        maskedPhone: string;
                    }>>;
                };
            };
        };
        enchantedLink: {
            verify: (token: string) => Promise<SdkResponse<never>>;
            signIn: (loginId: string, uri: string) => Promise<SdkResponse<_descope_core_js_sdk.EnchantedLinkResponse & {
                refreshJwt?: string;
                cookies?: string[];
            }>>;
            signUpOrIn: (loginId: string, uri: string) => Promise<SdkResponse<_descope_core_js_sdk.EnchantedLinkResponse>>;
            signUp: (loginId: string, uri: string, user?: {
                email?: string;
                name?: string;
                givenName?: string;
                middleName?: string;
                familyName?: string;
                phone?: string;
            }) => Promise<SdkResponse<_descope_core_js_sdk.EnchantedLinkResponse & {
                refreshJwt?: string;
                cookies?: string[];
            }>>;
            waitForSession: (pendingRef: string, config?: {
                pollingIntervalMs: number;
                timeoutMs: number;
            }) => Promise<SdkResponse<_descope_core_js_sdk.JWTResponse>>;
            update: {
                email: <T_4 extends boolean>(loginId: string, email: string, URI?: string, token?: string, updateOptions?: {
                    addToLoginIDs?: T_4;
                    onMergeUseExisting?: T_4 extends true ? boolean : never;
                }) => Promise<SdkResponse<_descope_core_js_sdk.EnchantedLinkResponse>>;
            };
        };
        oauth: {
            start: ((provider: string, redirectUrl?: string, loginOptions?: _descope_core_js_sdk.LoginOptions, token?: string) => Promise<SdkResponse<_descope_core_js_sdk.ResponseData>>) & {
                facebook: (redirectURL?: string, loginOptions?: _descope_core_js_sdk.LoginOptions, token?: string) => Promise<SdkResponse<_descope_core_js_sdk.URLResponse>>;
                github: (redirectURL?: string, loginOptions?: _descope_core_js_sdk.LoginOptions, token?: string) => Promise<SdkResponse<_descope_core_js_sdk.URLResponse>>;
                google: (redirectURL?: string, loginOptions?: _descope_core_js_sdk.LoginOptions, token?: string) => Promise<SdkResponse<_descope_core_js_sdk.URLResponse>>;
                microsoft: (redirectURL?: string, loginOptions?: _descope_core_js_sdk.LoginOptions, token?: string) => Promise<SdkResponse<_descope_core_js_sdk.URLResponse>>;
                gitlab: (redirectURL?: string, loginOptions?: _descope_core_js_sdk.LoginOptions, token?: string) => Promise<SdkResponse<_descope_core_js_sdk.URLResponse>>;
                apple: (redirectURL?: string, loginOptions?: _descope_core_js_sdk.LoginOptions, token?: string) => Promise<SdkResponse<_descope_core_js_sdk.URLResponse>>;
                discord: (redirectURL?: string, loginOptions?: _descope_core_js_sdk.LoginOptions, token?: string) => Promise<SdkResponse<_descope_core_js_sdk.URLResponse>>;
                linkedin: (redirectURL?: string, loginOptions?: _descope_core_js_sdk.LoginOptions, token?: string) => Promise<SdkResponse<_descope_core_js_sdk.URLResponse>>;
                slack: (redirectURL?: string, loginOptions?: _descope_core_js_sdk.LoginOptions, token?: string) => Promise<SdkResponse<_descope_core_js_sdk.URLResponse>>;
            };
            exchange: (code: string) => Promise<SdkResponse<_descope_core_js_sdk.JWTResponse & {
                refreshJwt?: string;
                cookies?: string[];
            }>>;
        };
        saml: {
            start: (tenantIdOrEmail: string, redirectUrl?: string, loginOptions?: _descope_core_js_sdk.LoginOptions, token?: string) => Promise<SdkResponse<_descope_core_js_sdk.URLResponse>>;
            exchange: (code: string) => Promise<SdkResponse<_descope_core_js_sdk.JWTResponse & {
                refreshJwt?: string;
                cookies?: string[];
            }>>;
        };
        totp: {
            signUp: (loginId: string, user?: {
                email?: string;
                name?: string;
                givenName?: string;
                middleName?: string;
                familyName?: string;
                phone?: string;
            }) => Promise<SdkResponse<_descope_core_js_sdk.TOTPResponse>>;
            verify: (loginId: string, code: string, loginOptions?: _descope_core_js_sdk.LoginOptions, token?: string) => Promise<SdkResponse<_descope_core_js_sdk.JWTResponse & {
                refreshJwt?: string;
                cookies?: string[];
            }>>;
            update: (loginId: string, token?: string) => Promise<SdkResponse<_descope_core_js_sdk.TOTPResponse>>;
        };
        webauthn: {
            signUp: {
                start: (loginId: string, origin: string, name: string) => Promise<SdkResponse<{
                    transactionId: string;
                    options: string;
                    create: boolean;
                }>>;
                finish: (transactionId: string, response: string) => Promise<SdkResponse<_descope_core_js_sdk.JWTResponse & {
                    refreshJwt?: string;
                    cookies?: string[];
                }>>;
            };
            signIn: {
                start: (loginId: string, origin: string, loginOptions?: _descope_core_js_sdk.LoginOptions, token?: string) => Promise<SdkResponse<{
                    transactionId: string;
                    options: string;
                    create: boolean;
                }>>;
                finish: (transactionId: string, response: string) => Promise<SdkResponse<_descope_core_js_sdk.JWTResponse & {
                    refreshJwt?: string;
                    cookies?: string[];
                }>>;
            };
            signUpOrIn: {
                start: (loginId: string, origin: string) => Promise<SdkResponse<{
                    transactionId: string;
                    options: string;
                    create: boolean;
                }>>;
            };
            update: {
                start: (loginId: string, origin: string, token: string) => Promise<SdkResponse<{
                    transactionId: string;
                    options: string;
                    create: boolean;
                }>>;
                finish: (transactionId: string, response: string) => Promise<SdkResponse<_descope_core_js_sdk.ResponseData>>;
            };
        };
        password: {
            signUp: (loginId: string, password: string, user?: {
                email?: string;
                name?: string;
                givenName?: string;
                middleName?: string;
                familyName?: string;
                phone?: string;
            }) => Promise<SdkResponse<_descope_core_js_sdk.JWTResponse>>;
            signIn: (loginId: string, password: string) => Promise<SdkResponse<_descope_core_js_sdk.JWTResponse>>;
            sendReset: (loginId: string, redirectUrl?: string) => Promise<SdkResponse<{
                resetMethod: string;
                pendingRef?: string;
                linkId?: string;
                maskedEmail: string;
            }>>;
            update: (loginId: string, newPassword: string, token?: string) => Promise<SdkResponse<never>>;
            replace: (loginId: string, oldPassword: string, newPassword: string) => Promise<SdkResponse<_descope_core_js_sdk.JWTResponse>>;
            policy: () => Promise<SdkResponse<{
                minLength: number;
                lowercase: boolean;
                uppercase: boolean;
                number: boolean;
                nonAlphanumeric: boolean;
            }>>;
        };
        flow: {
            start: (flowId: string, options?: {
                redirectUrl?: string;
                location?: string;
                tenant?: string;
                deviceInfo?: {
                    webAuthnSupport?: boolean;
                };
                lastAuth?: {
                    authMethod?: "otp" | "oauth" | "saml" | "totp" | "webauthn" | "magiclink" | "enchantedlink";
                    oauthProvider?: string;
                    name?: string;
                    loginId?: string;
                };
                redirectAuth?: {
                    callbackUrl: string;
                    codeChallenge: string;
                };
                oidcIdpStateId?: string;
                preview?: boolean;
                samlIdpStateId?: string;
                samlIdpUsername?: string;
                ssoAppId?: string;
                abTestingKey?: number;
                startOptionsVersion?: number;
                client?: Record<string, any>;
            }, conditionInteractionId?: string, interactionId?: string, version?: number, componentsVersion?: string, input?: {
                [x: string]: string | number | boolean | (string | number | boolean | (string | number | boolean | (string | number | boolean | (string | number | boolean | (string | number | boolean | (string | number | boolean | (string | number | boolean | (string | number | boolean | (string | number | boolean | (string | number | boolean | (string | number | boolean | any)[])[])[])[])[])[])[])[])[])[])[];
            }) => Promise<SdkResponse<_descope_core_js_sdk.FlowResponse>>;
            next: (executionId: string, stepId: string, interactionId: string, version?: number, componentsVersion?: string, input?: {
                [x: string]: string | number | boolean | (string | number | boolean | (string | number | boolean | (string | number | boolean | (string | number | boolean | (string | number | boolean | (string | number | boolean | (string | number | boolean | (string | number | boolean | (string | number | boolean | (string | number | boolean | (string | number | boolean | any)[])[])[])[])[])[])[])[])[])[])[];
            }) => Promise<SdkResponse<_descope_core_js_sdk.FlowResponse>>;
        };
        refresh: (token?: string) => Promise<SdkResponse<_descope_core_js_sdk.JWTResponse & {
            refreshJwt?: string;
            cookies?: string[];
        }>>;
        selectTenant: (tenantId: string, token?: string) => Promise<SdkResponse<_descope_core_js_sdk.JWTResponse>>;
        logout: (token?: string) => Promise<SdkResponse<never>>;
        logoutAll: (token?: string) => Promise<SdkResponse<never>>;
        me: (token?: string) => Promise<SdkResponse<_descope_core_js_sdk.UserResponse>>;
        isJwtExpired: (token: string) => boolean;
        getTenants: (token: string) => string[];
        getJwtPermissions: (token: string, tenant?: string) => string[];
        getJwtRoles: (token: string, tenant?: string) => string[];
        httpClient: {
            get: (path: string, config?: {
                headers?: HeadersInit;
                queryParams?: {
                    [key: string]: string;
                };
                token?: string;
            }) => Promise<Response>;
            post: (path: string, body?: any, config?: {
                headers?: HeadersInit;
                queryParams?: {
                    [key: string]: string;
                };
                token?: string;
            }) => Promise<Response>;
            put: (path: string, body?: any, config?: {
                headers?: HeadersInit;
                queryParams?: {
                    [key: string]: string;
                };
                token?: string;
            }) => Promise<Response>;
            delete: (path: string, config?: {
                headers?: HeadersInit;
                queryParams?: {
                    [key: string]: string;
                };
                token?: string;
            }) => Promise<Response>;
            hooks?: {
                beforeRequest?: (config: _descope_core_js_sdk.RequestConfig) => _descope_core_js_sdk.RequestConfig;
                afterRequest?: (req: _descope_core_js_sdk.RequestConfig, res: Response) => void | Promise<void>;
            };
        };
    };
    /** Descope SDK client with delivery methods enum.
     *
     * Please see full documentation at {@link https://docs.descope.com/guides Descope Docs}
     * @example Usage
     *
     * ```js
     * import descopeSdk from '@descope/node-sdk';
     *
     * const myProjectId = 'xxx';
     * const sdk = descopeSdk({ projectId: myProjectId });
     *
     * const userLoginId = 'loginId';
     * sdk.otp.signIn.email(userLoginId);
     * const jwtResponse = sdk.otp.verify.email(userLoginId, codeFromEmail);
     * ```
     */
    RefreshTokenCookieName: string;
    SessionTokenCookieName: string;
};

export { AuthenticationInfo, nodeSdk as default, descopeErrors };
